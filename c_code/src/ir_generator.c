/*
 * ir_generator.c
 * IR Instruction Generation - Extracted from ael49_dll.c
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include "ael_debug.h"
#include "ir_generator.h"
#include "opcode_metadata.h"

/* Treat IR generator printf/fflush(stdout) as debug-only output. */
#define printf AEL_DEBUG_PRINTF
#define fflush(x) AEL_DEBUG_FLUSH()

/* Global state */
int AcompDepth = 0;
int AcompInteract = 1;  // Always use IR generation mode
int AerrFlag = 0;
static int local_var_count = 0;  // Track number of local variables
static int label_counter = 0;     // Label counter (reset per function)

/* IR Instruction linked list */
typedef struct IRInst {
    struct IRInst *next;
    int opcode;
    union {
        int64_t int_val;
        double real_val;
        char *str_val;
    };
    int arg1, arg2, arg3, arg4;  /* Changed from int16_t to int to support larger values */
    int depth;  // Store depth per instruction
    int line, column;
} IRInst;

static IRInst *g_ir_head = NULL;
static IRInst *g_ir_tail = NULL;
static int g_ir_count = 0;

/* Helper: Create IR instruction */
static IRInst *create_ir_inst(int opcode) {
    IRInst *inst = (IRInst *)calloc(1, sizeof(IRInst));
    if (!inst) {
        fprintf(stderr, "Error: Out of memory\n");
        exit(1);
    }
    inst->opcode = opcode;
    inst->depth = AcompDepth;  // Capture current depth

    // Add to linked list
    if (g_ir_tail) {
        g_ir_tail->next = inst;
        g_ir_tail = inst;
    } else {
        g_ir_head = inst;
        g_ir_tail = inst;
    }
    g_ir_count++;

    return inst;
}

/* Initialize IR generation system */
void ir_init(void)
{
    /* Reset IR instruction list */
    g_ir_head = NULL;
    g_ir_tail = NULL;
    g_ir_count = 0;

    /* Set IR generation mode */
    AcompInteract = 1;  // 1 = IR mode, 0 = ATF mode

    /* Reset depth */
    AcompDepth = 0;

    printf("[ir_init] IR generation system initialized\n");
    printf("  AcompInteract = %d (IR mode)\n", AcompInteract);
    printf("  Instruction count = %d\n", g_ir_count);
}

/* Get current instruction count */
int ir_get_count(void)
{
    return g_ir_count;
}

/* Helper: Get opcode name with function name */
static const char *get_opcode_name(int opcode) {
    switch (opcode) {
        case 3: return "LOAD_INT (acomp_integer)";
        case 4: return "LOAD_STR (acomp_string)";
        case 5: return "LOAD_BOOL (acomp_bool)";
        case 7: return "LOAD_TRUE (acomp_true)";
        case 8: return "LOAD_REAL (acomp_real)";
        case 9: return "LOAD_IMAG (acomp_imag)";
        case 10: return "LOAD_NULL (acomp_null)";
        case 16: return "LOAD_VAR (acomp_word_ref)";
        case 20: return "ADD_LOCAL (acomp_add_local)";
        case 32: return "BEGIN_FUNCT (acomp_begin_funct)";
        case 33: return "DEFINE_FUNCT (acomp_define_funct)";
        case 34: return "BRANCH_TRUE (acomp_branch_true)";
        case 36: return "BEGIN_LOOP (acomp_begin_loop)";
        case 37: return "END_LOOP (acomp_end_loop)";
        case 38: return "LOOP_AGAIN (continue) (acomp_loop_again)";
        case 39: return "LOOP_EXIT (break) (acomp_loop_exit)";
        case 40: return "ADD_CASE (acomp_add_case)";
        case 41: return "BRANCH_TABLE (acomp_branch_table)";
        case 42: return "SET_LABEL (acomp_set_label)";
        case 43: return "ADD_LABEL (acomp_add_label)";
        case 44: return "ADD_GLOBAL (acomp_add_global)";
        case 45: return "ADD_ARG (acomp_add_arg)";
        case 48: return "OP (acomp_op)";
        case 52: return "NUM_LOCAL (acomp_num_local)";
        case 53: return "SET_LOOP_DEFAULT (acomp_set_loop_default)";
        case 55: return "DROP_LOCAL (acomp_drop_local)";
        default: return "UNKNOWN";
    }
}

/* Output IR to file */
void ir_output_to_file(const char *filename) {
    FILE *fp = fopen(filename, "w");
    if (!fp) {
        fprintf(stderr, "Error: Cannot open output file: %s\n", filename);
        return;
    }

    fprintf(fp, "# AEL IR Log\n");
    fprintf(fp, "# Generated by ael2ir compiler\n");
    fprintf(fp, "#\n\n");

    IRInst *inst = g_ir_head;
    int addr = 0;

    while (inst) {
        fprintf(fp, "[%04X] OP=%3d", addr, inst->opcode);

        // Display arguments based on opcode type
        switch (inst->opcode) {
            case 3:  // LOAD_INT
                fprintf(fp, "  arg1=%5d  arg2=%5d  arg3=%5d",
                        inst->arg1, inst->arg2, inst->arg3);
                break;

            case 8:  // LOAD_REAL
                fprintf(fp, "  arg1=%5d  arg2=%5d  arg3=%5d",
                        inst->arg1, inst->arg2, inst->arg3);
                break;

            case 9:  // LOAD_IMAG
                fprintf(fp, "  arg1=%5d  arg2=%5d  arg3=%5d",
                        inst->arg1, inst->arg2, inst->arg3);
                break;

            case 4:   // LOAD_STRING
            case 16:  // LOAD_VAR
            case 20:  // ADD_LOCAL
            case 44:  // ADD_GLOBAL
            case 45:  // ADD_ARG
                if (inst->str_val) {
                    fprintf(fp, "  str=\"%s\"", inst->str_val);
                }
                break;

            case 32:  // BEGIN_FUNCT
                if (inst->str_val) {
                    fprintf(fp, "  str=\"%s\"", inst->str_val);
                }
                fprintf(fp, " arg1=%5d arg2=%5d", inst->arg1, inst->arg2);
                break;

            case 48:  // OP
                fprintf(fp, "  arg1=%5d  arg2=%5d  arg3=%5d  a4=%d",
                        inst->arg1, inst->arg2, inst->arg3, inst->arg4);
                break;

            case 52:  // NUM_LOCAL
            case 55:  // DROP_LOCAL
            case 33:  // DEFINE_FUNCT
            case 34:  // BRANCH_TRUE
            case 42:  // SET_LABEL
            case 43:  // ADD_LABEL
                fprintf(fp, "  arg1=%5d  arg2=%5d  arg3=%5d",
                        inst->arg1, inst->arg2, inst->arg3);
                break;

            default:
                // For other opcodes, always display args
                fprintf(fp, "  arg1=%5d  arg2=%5d  arg3=%5d",
                        inst->arg1, inst->arg2, inst->arg3);
                if (inst->arg4 != 0) {
                    fprintf(fp, "  a4=%d", inst->arg4);
                }
                break;
        }

        // Add opcode name comment
        // Special handling for opcodes with extra info
        if (inst->opcode == 48) {  // OP
            fprintf(fp, "  # OP=%d (acomp_op)", inst->arg1);
        } else if (inst->opcode == 55) {  // DROP_LOCAL
            fprintf(fp, "  # DROP_LOCAL count=%d (acomp_drop_local)", inst->arg1);
        } else if (inst->opcode == 5) {  // LOAD_BOOL
            fprintf(fp, "  # LOAD_BOOL val=%s (acomp_bool)", inst->arg1 ? "true" : "false");
        } else if (inst->opcode == 8) {  // LOAD_REAL
            fprintf(fp, "  # LOAD_REAL val=%.17e (acomp_real)", inst->real_val);
        } else if (inst->opcode == 9) {  // LOAD_IMAG
            fprintf(fp, "  # LOAD_IMAG val=%fi (acomp_imag)", inst->real_val);
        } else if (inst->opcode == 44 && inst->str_val) {  // ADD_GLOBAL
            fprintf(fp, "  # ADD_GLOBAL name=%s (acomp_add_global)", inst->str_val);
        } else if (inst->opcode == 20 && inst->str_val) {  // ADD_LOCAL
            fprintf(fp, "  # ADD_LOCAL (acomp_add_local)");
        } else if (inst->opcode == 32 && inst->str_val) {  // BEGIN_FUNCT
            fprintf(fp, "  # BEGIN_FUNCT name=%s (acomp_begin_funct)", inst->str_val);
        } else if (inst->opcode == 45 && inst->str_val) {  // ADD_ARG
            fprintf(fp, "  # ADD_ARG name=%s (acomp_add_arg)", inst->str_val);
        } else if (inst->opcode == 34) {  // BRANCH_TRUE
            fprintf(fp, "  # BRANCH_TRUE label=%d (acomp_branch_true)", inst->arg1);
        } else if (inst->opcode == 42) {  // SET_LABEL
            fprintf(fp, "  # SET_LABEL label_id=%d (acomp_set_label)", inst->arg1);
        } else if (inst->opcode == 43) {  // ADD_LABEL
            fprintf(fp, "  # ADD_LABEL (acomp_add_label)");
        } else if (inst->opcode == 40) {  // ADD_CASE
            fprintf(fp, "  # ADD_CASE case_value=%d (acomp_add_case)", inst->arg1);
        } else if (inst->opcode == 41) {  // BRANCH_TABLE
            fprintf(fp, "  # BRANCH_TABLE line=%d col=%d (acomp_branch_table)", inst->arg1, inst->arg2);
        } else if (inst->opcode == 53) {  // SET_LOOP_DEFAULT
            fprintf(fp, "  # SET_LOOP_DEFAULT (acomp_set_loop_default)");
        } else {
            fprintf(fp, "  # %s", get_opcode_name(inst->opcode));
        }

        fprintf(fp, "\n");

        // Only output DEPTH comment for non-OP=48 instructions
        if (inst->opcode != 48) {
            fprintf(fp, "    # DEPTH=%d\n", inst->depth);
        }

        inst = inst->next;
        addr++;
    }

    fprintf(fp, "\n# End of IR log (Total: %d instructions)\n", g_ir_count);
    fclose(fp);
}

/* Free all IR instructions */
void ir_free_all() {
    IRInst *inst = g_ir_head;
    while (inst) {
        IRInst *next = inst->next;
        // Only free str_val for opcodes that use strings
        // Opcodes with strings: 4(LOAD_STRING), 16(LOAD_VAR), 20(ADD_LOCAL),
        // 32(BEGIN_FUNCT), 44(ADD_GLOBAL), 45(ADD_ARG)
        if (inst->opcode == 4 || inst->opcode == 16 || inst->opcode == 20 ||
            inst->opcode == 32 || inst->opcode == 44 || inst->opcode == 45) {
            if (inst->str_val) free(inst->str_val);
        }
        free(inst);
        inst = next;
    }
    g_ir_head = NULL;
    g_ir_tail = NULL;
    g_ir_count = 0;
}

/* ========== IR Generation Functions ========== */

/* OP=3: Load integer constant */
bool acomp_integer(int value) {
    IRInst *inst = create_ir_inst(3);
    inst->arg1 = value;
    inst->arg2 = 0;
    inst->arg3 = 0;
    return true;
}

/* OP=8: Load real constant */
bool acomp_real(double value) {
    IRInst *inst = create_ir_inst(8);
    inst->real_val = value;
    inst->arg1 = 0;
    inst->arg2 = 0;
    inst->arg3 = 0;
    return true;
}

/* OP=9: Load imaginary constant */
bool acomp_imag(double value) {
    IRInst *inst = create_ir_inst(9);
    inst->real_val = value;
    inst->arg1 = 0;
    inst->arg2 = 0;
    inst->arg3 = 0;
    return true;
}

/* OP=4: Load string constant */
bool acomp_string(const char *str) {
    IRInst *inst = create_ir_inst(4);
    inst->str_val = strdup(str);
    return true;
}

/* OP=10: Load NULL */
bool acomp_null() {
    create_ir_inst(10);
    return true;
}

/* OP=5: Load BOOL (generic boolean) */
bool acomp_bool(bool value) {
    IRInst *inst = create_ir_inst(5);
    inst->arg1 = value ? 1 : 0;
    inst->arg2 = 0;
    inst->arg3 = 0;
    return true;
}

/* OP=7: Load TRUE */
bool acomp_true() {
    IRInst *inst = create_ir_inst(7);
    inst->arg1 = 1;
    inst->arg2 = 0;
    inst->arg3 = 0;
    return true;
}

/* Load FALSE (using OP=5) */
bool acomp_false() {
    return acomp_bool(false);
}

/* OP=44: Add global variable */
bool acomp_add_global(void *vocab_ptr, const char *name) {
    printf("[IR] acomp_add_global(\"%s\") called\n", name ? name : "(null)");
    fflush(stdout);
    IRInst *inst = create_ir_inst(44);
    inst->str_val = strdup(name);
    return true;
}

/* OP=20: Add local variable */
bool acomp_add_local(const char *name) {
    printf("[IR] acomp_add_local(\"%s\") called\n", name ? name : "(null)");
    fflush(stdout);
    local_var_count++;  // Increment local variable counter
    IRInst *inst = create_ir_inst(20);
    inst->str_val = strdup(name);
    return true;
}

/* OP=16: Load variable */
bool acomp_word_ref(void *vocab_ptr, const char *name) {
    printf("[IR] acomp_word_ref(\"%s\") called\n", name ? name : "(null)");
    fflush(stdout);
    IRInst *inst = create_ir_inst(16);
    inst->str_val = strdup(name);
    return true;
}

/* OP=48: Generic operation */
bool acomp_op(int16_t opcode, int16_t arg2, int16_t arg3, int arg4) {
    /* arg2 = line number, arg3 = column number (from lexer position tracking) */
    /* These are now passed directly from parser, no metadata lookup needed */

    IRInst *inst = create_ir_inst(48);
    inst->arg1 = opcode;
    inst->arg2 = arg2;
    inst->arg3 = arg3;
    inst->arg4 = arg4;
    return true;
}

/* OP=52: Number of local variables */
int acomp_num_local() {
    printf("[IR] acomp_num_local() called, returning %d\n", local_var_count);
    fflush(stdout);
    IRInst *inst = create_ir_inst(52);
    inst->arg1 = 0;  // Always 0 according to baseline IR
    inst->arg2 = 0;
    inst->arg3 = 0;
    return local_var_count;
}

/* OP=55: Drop local variables */
void acomp_drop_local(int count) {
    printf("[IR] acomp_drop_local(%d) called\n", count);
    fflush(stdout);
    local_var_count = count;  // Reset local variable count
    IRInst *inst = create_ir_inst(55);
    inst->arg1 = count;
    inst->arg2 = 0;
    inst->arg3 = 0;
}

/* Get current local variable count (excludes parameters) */
int ir_get_local_count(void) {
    return local_var_count;
}

/* OP=32: Begin function definition */
bool acomp_begin_funct(void *vocab_ptr, const char *name, int arg_count, int16_t func_word_id, int source_line) {
    printf("[IR] acomp_begin_funct(\"%s\") called, source_line=%d\n", name ? name : "(null)", source_line);
    fflush(stdout);

    /* Reset label counter for this function */
    label_counter = 0;

    IRInst *inst = create_ir_inst(32);
    inst->str_val = strdup(name);
    inst->arg1 = source_line;  /* arg1 = source line number of defun (0-based) */
    inst->arg2 = func_word_id;
    printf("[IR] acomp_begin_funct: arg1=%d (source_line)\n", inst->arg1);
    fflush(stdout);
    return true;
}

/* OP=33: Define function */
bool acomp_define_funct(int local_count, int16_t func_word_id) {
    IRInst *inst = create_ir_inst(33);
    inst->arg1 = local_count;
    inst->arg2 = func_word_id;

    /* Reset label counter when exiting function (returning to global scope) */
    label_counter = 0;

    return true;
}

/* OP=45: Add function argument */
bool acomp_add_arg(const char *name) {
    IRInst *inst = create_ir_inst(45);
    inst->str_val = strdup(name);
    return true;
}

/* OP=43: Add label */
int acomp_add_label() {
    IRInst *inst = create_ir_inst(43);
    inst->arg1 = 0;  // arg1 always 0 for ADD_LABEL
    return label_counter++;
}

/* OP=42: Set label */
bool acomp_set_label(int label_id) {
    IRInst *inst = create_ir_inst(42);
    inst->arg1 = label_id;
    return true;
}

/* OP=34: Branch if true */
bool acomp_branch_true(int label_id, int16_t line, int16_t col) {
    IRInst *inst = create_ir_inst(34);
    inst->arg1 = label_id;
    inst->arg2 = line;
    inst->arg3 = col;
    return true;
}

/* OP=36: Begin loop */
bool acomp_begin_loop() {
    create_ir_inst(36);
    return true;
}

/* OP=37: End loop */
bool acomp_end_loop() {
    create_ir_inst(37);
    return true;
}

/* OP=38: Loop again (continue) */
int acomp_loop_again() {
    IRInst *inst = create_ir_inst(38);
    return 0;  // Return label ID
}

/* OP=39: Loop exit (break) */
int acomp_loop_exit() {
    IRInst *inst = create_ir_inst(39);
    return 0;  // Return label ID
}

/* OP=40: Add case for switch statement */
bool acomp_add_case(int case_value) {
    IRInst *inst = create_ir_inst(40);
    inst->arg1 = case_value;
    return true;
}

/* OP=53: Set loop default (for switch statement default case) */
bool acomp_set_loop_default(void) {
    IRInst *inst = create_ir_inst(53);
    return true;
}

/* OP=41: Branch table (for switch statement) */
bool acomp_branch_table(int16_t line, int16_t col) {
    IRInst *inst = create_ir_inst(41);
    inst->arg1 = line;
    inst->arg2 = col;
    inst->arg3 = 0;
    return true;
}

/* Open ATF file (we don't need this for IR generation) */
bool acomp_open_atf(const char *filename, const char *source_name, int mode) {
    AcompInteract = 1;  // Force IR generation mode
    return true;
}

/* Close ATF file */
bool acomp_close_atf() {
    return true;
}
