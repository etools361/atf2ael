/* autogenerated: flow handler */
#include "ir2ael_internal.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

Ir2AelStatus ir2ael_flow_handle_end_loop(Ir2AelState *s, size_t *idx, const IRInst *inst) {
    if (!s || !inst || !idx) return IR2AEL_STATUS_FAIL;
    Ir2AelState *st = s;
    const IRProgram *program = s->program;
    AelEmitter *out = s->out;
    char *err = s->err;
    size_t err_cap = s->err_cap;
    size_t i = *idx;

#define RETURN_STATUS(_status) do { *idx = i; return (_status); } while (0)

    if (inst->op == OP_END_LOOP) {
        do {
            if (st->loop_sp > 0 && st->loop_stack[st->loop_sp - 1].kind == 3) {
                LoopCtx *lctx = &st->loop_stack[st->loop_sp - 1];
                bool is_this_for_end = false;
                if (lctx->end_label >= 0 && i > 0) {
                    size_t prev_idx = ir_skip_locals_bookkeeping_back(program, i);
                    if (prev_idx > 0) {
                        const IRInst *prev = &program->insts[prev_idx - 1];
                        if (prev->op == OP_SET_LABEL && prev->has_arg1 && prev->arg1 == lctx->end_label) {
                            is_this_for_end = true;
                        }
                    }
                }
                if (is_this_for_end) {
                    if (lctx->body_has_brace) {
                        if (!ael_emit_text(out, "}\n")) goto fail_emit;
                        anon_depth_pop_expected(&st->anon_depth_sp, st->anon_depth_stack, st->cur_depth + 1, true);
                    }
                    st->loop_sp--;
                }
            }
            if (st->sw.active) {
                if (!switch_emit_pending_case_label_only(out, &st->sw, &st->anon_depth_sp, st->anon_depth_stack)) goto fail_emit;
                int close_line0 = out->line0;
                int min_close_line0 = (st->sw.last_break_line0 >= 0) ? (st->sw.last_break_line0 + 1) : (st->sw.line0 + 1);
                if (close_line0 < min_close_line0) close_line0 = min_close_line0;
                if (!st->sw.opened) {
                    if (!ael_emit_text(out, " {\n")) goto fail_emit;
                    st->sw.opened = true;
                    (void)anon_depth_push_marked(&st->anon_depth_sp, st->anon_depth_stack, st->sw.depth + 1, true);
                }
                if (close_line0 < out->line0) close_line0 = out->line0;
                if (!ael_emit_at(out, close_line0, st->sw.col0)) goto fail_emit;
                if (!ael_emit_text(out, "}\n")) goto fail_emit;
                anon_depth_pop_expected(&st->anon_depth_sp, st->anon_depth_stack, st->sw.depth + 1, true);
                st->sw.active = false;
            }
            continue;
        } while (0);
        RETURN_STATUS(IR2AEL_STATUS_HANDLED);
    }
    RETURN_STATUS(IR2AEL_STATUS_NOT_HANDLED);
fail_emit:
    RETURN_STATUS(IR2AEL_STATUS_FAIL_EMIT);
#undef RETURN_STATUS
}
