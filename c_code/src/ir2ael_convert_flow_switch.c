/* autogenerated: flow handler */
#include "ir2ael_internal.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

Ir2AelStatus ir2ael_flow_handle_switch_ops(Ir2AelState *s, size_t *idx, const IRInst *inst) {
    if (!s || !inst || !idx) return IR2AEL_STATUS_FAIL;
    Ir2AelState *st = s;
    const IRProgram *program = s->program;
    AelEmitter *out = s->out;
    char *err = s->err;
    size_t err_cap = s->err_cap;
    size_t i = *idx;

#define RETURN_STATUS(_status) do { *idx = i; return (_status); } while (0)

    if (inst->op == OP_BRANCH_TABLE) {
        do {
                /* Switch header is emitted at BEGIN_LOOP (when the switch expression is available). */
                continue;
        } while (0);
        RETURN_STATUS(IR2AEL_STATUS_HANDLED);
    }
    if (inst->op == OP_ADD_CASE) {
        do {
                if (st->sw.active && inst->has_arg1) {
                    if (!switch_emit_pending_case_label_only(out, &st->sw, &st->anon_depth_sp, st->anon_depth_stack)) goto fail_emit;
                    st->sw.pending_case_kind = 1;
                    st->sw.pending_case_value = inst->arg1;
                    st->sw.pending_case_emitted = false;
                }
                continue;
        } while (0);
        RETURN_STATUS(IR2AEL_STATUS_HANDLED);
    }
    if (inst->op == OP_SET_LOOP_DEFAULT) {
        do {
                if (st->sw.active) {
                    if (!switch_emit_pending_case_label_only(out, &st->sw, &st->anon_depth_sp, st->anon_depth_stack)) goto fail_emit;
                    st->sw.pending_case_kind = 2;
                    st->sw.pending_case_emitted = false;
                }
                continue;
        } while (0);
        RETURN_STATUS(IR2AEL_STATUS_HANDLED);
    }

    RETURN_STATUS(IR2AEL_STATUS_NOT_HANDLED);
fail_emit:
    RETURN_STATUS(IR2AEL_STATUS_FAIL_EMIT);
#undef RETURN_STATUS
}
