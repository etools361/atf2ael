/* autogenerated: expr handler */
#include "ir2ael_internal.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

Ir2AelStatus ir2ael_expr_handle_misc_ops(Ir2AelState *s, size_t *idx, const IRInst *inst) {
    if (!s || !inst || !idx) return IR2AEL_STATUS_FAIL;
    if (inst->op != OP_OP) return IR2AEL_STATUS_NOT_HANDLED;
    Ir2AelState *st = s;
    const IRProgram *program = s->program;
    AelEmitter *out = s->out;
    char *err = s->err;
    size_t err_cap = s->err_cap;
    size_t i = *idx;
    int op_code = inst->has_arg1 ? inst->arg1 : 0;
    if (!(1)) return IR2AEL_STATUS_NOT_HANDLED;

#define RETURN_STATUS(_status) do { *idx = i; return (_status); } while (0)

    do {
            if (op_code == 36) {
                /* LVALUE marker (used for compound assignment): duplicate top expression. */
                if (st->stack_len == 0 || !st->stack[st->stack_len - 1]) {
                    if (err && err_cap) snprintf(err, err_cap, "bad lvalue st->stack at IR index %zu", i);
                    goto fail;
                }
                Expr *dup = expr_clone(st->stack[st->stack_len - 1]);
                if (!dup) goto oom;
                dup->flags |= EXPR_FLAG_LVALUE_DUP;
                dup->op_line0 = inst->has_arg2 ? inst->arg2 : -1;
                dup->op_col0 = inst->has_arg3 ? inst->arg3 : -1;
                if (!stack_push(&st->stack, &st->stack_len, &st->stack_cap, dup)) {
                    expr_free(dup);
                    goto oom;
                }
                continue;
            }

            if (op_code == 31 || op_code == 32 || op_code == 33 || op_code == 34) {
                Expr *v = stack_pop(st->stack, &st->stack_len);
                if (!v) {
                    if (err && err_cap) snprintf(err, err_cap, "bad inc/dec st->stack at IR index %zu", i);
                    goto fail;
                }
                Expr *e = expr_new(EXPR_INCDEC);
                if (!e) {
                    expr_free(v);
                    goto oom;
                }
                e->lhs = v;
                e->incdec_is_inc = (op_code == 31 || op_code == 33);
                e->incdec_is_prefix = (op_code == 31 || op_code == 32);
                e->op_code = op_code;
                e->op_line0 = inst->has_arg2 ? inst->arg2 : -1;
                e->op_col0 = inst->has_arg3 ? inst->arg3 : -1;
                if (e->lhs && e->lhs->kind == EXPR_VAR && e->lhs->text) {
                    local_init_mark_assigned(&st->local_init, e->lhs->text);
                }

                /* for-header update: "for (...; ...; i++)" has no STMT_END after the update expression.
                   Emit it directly into the in-flight for-header so we don't create a standalone statement. */
                if (st->for_hdr_sp > 0 && st->for_hdr_stack[st->for_hdr_sp - 1].stage == 2 &&
                    inst->has_arg2 && inst->arg2 == st->for_hdr_stack[st->for_hdr_sp - 1].line0 &&
                    !for_header_has_comma_op(program, i, st->for_hdr_stack[st->for_hdr_sp - 1].line0)) {
                    int line0 = inst->arg2;
                    int start_col0 = expr_start_col0(e, line0);
                    if (start_col0 < out->col0) start_col0 = out->col0;
                    if (!ael_emit_at(out, line0, start_col0)) {
                        expr_free(e);
                        goto fail_emit;
                    }
                    if (!emit_expr_addr(out, e, 0)) {
                        expr_free(e);
                        goto fail_emit;
                    }
                    expr_free(e);
                    st->for_hdr_stack[st->for_hdr_sp - 1].stage = 3;
                    stack_clear(st->stack, &st->stack_len);
                    continue;
                }

                if (!stack_push(&st->stack, &st->stack_len, &st->stack_cap, e)) {
                    expr_free(e);
                    goto oom;
                }
                continue;
            }

            if (op_code == 47) {
                int argc = inst->has_a4 ? inst->a4 : 2;
                if (argc < 2) argc = 2;
                Expr **args = (Expr **)calloc((size_t)argc, sizeof(Expr *));
                if (!args) goto oom;
                for (int k = argc - 1; k >= 0; k--) {
                    Expr *arg = stack_pop(st->stack, &st->stack_len);
                    if (!arg) {
                        arg = expr_new(EXPR_INT);
                        if (!arg) {
                            for (int t = k + 1; t < argc; t++) expr_free(args[t]);
                            free(args);
                            goto oom;
                        }
                        arg->int_value = 0;
                    }
                    args[k] = arg;
                }
                Expr *cur = args[0];
                for (int k = 1; k < argc; k++) {
                    Expr *e = expr_new(EXPR_BINOP);
                    if (!e) {
                        expr_free(cur);
                        for (int t = k; t < argc; t++) expr_free(args[t]);
                        free(args);
                        goto oom;
                    }
                    e->op_code = 47;
                    e->op_line0 = inst->has_arg2 ? inst->arg2 : -1;
                    e->op_col0 = inst->has_arg3 ? inst->arg3 : -1;
                    e->lhs = cur;
                    e->rhs = args[k];
                    cur = e;
                }
                free(args);
                if (!stack_push(&st->stack, &st->stack_len, &st->stack_cap, cur)) {
                    expr_free(cur);
                    goto oom;
                }
                continue;
            }

            const char *op_str = op_code_to_str(op_code);
            if (!op_str) {
                int argc = inst->has_a4 ? inst->a4 : 0;
                if (argc <= 0) argc = 1;
                Expr **args = (Expr **)calloc((size_t)argc, sizeof(Expr *));
                if (!args) goto oom;
                for (int k = argc - 1; k >= 0; k--) {
                    Expr *arg = stack_pop(st->stack, &st->stack_len);
                    if (!arg) {
                        arg = expr_new(EXPR_INT);
                        if (!arg) {
                            for (int t = k + 1; t < argc; t++) expr_free(args[t]);
                            free(args);
                            goto oom;
                        }
                        arg->int_value = 0;
                    }
                    args[k] = arg;
                }
                char op_name[32];
                snprintf(op_name, sizeof(op_name), "__op%d", op_code);
                Expr *callee = expr_new(EXPR_VAR);
                if (!callee) {
                    for (int t = 0; t < argc; t++) expr_free(args[t]);
                    free(args);
                    goto oom;
                }
                callee->text = _strdup(op_name);
                if (!callee->text) {
                    expr_free(callee);
                    for (int t = 0; t < argc; t++) expr_free(args[t]);
                    free(args);
                    goto oom;
                }
                Expr *ce = expr_new(EXPR_CALL);
                if (!ce) {
                    expr_free(callee);
                    for (int t = 0; t < argc; t++) expr_free(args[t]);
                    free(args);
                    goto oom;
                }
                ce->lhs = callee;
                ce->call_args = args;
                ce->call_arg_count = argc;
                ce->op_line0 = inst->has_arg2 ? inst->arg2 : -1;
                ce->op_col0 = inst->has_arg3 ? inst->arg3 : -1;
                if (!stack_push(&st->stack, &st->stack_len, &st->stack_cap, ce)) {
                    expr_free(ce);
                    goto oom;
                }
                continue;
            }

            if (op_code == 3 || op_code == 15) {
                /* unary */
                Expr *a = stack_pop(st->stack, &st->stack_len);
                if (!a) {
                    if (err && err_cap) snprintf(err, err_cap, "bad unary st->stack at IR index %zu", i);
                    goto fail;
                }
                Expr *e = expr_new(EXPR_UNOP);
                if (!e) {
                    expr_free(a);
                    goto oom;
                }
                e->op_code = op_code;
                e->op_line0 = inst->has_arg2 ? inst->arg2 : -1;
                e->op_col0 = inst->has_arg3 ? inst->arg3 : -1;
                e->rhs = a;
                if (!stack_push(&st->stack, &st->stack_len, &st->stack_cap, e)) {
                    expr_free(e);
                    goto oom;
                }
            } else {
                /* binary */
                Expr *rhs = stack_pop(st->stack, &st->stack_len);
                Expr *lhs = stack_pop(st->stack, &st->stack_len);
                if (!rhs || !lhs) {
                    expr_free(rhs);
                    expr_free(lhs);
                    if (err && err_cap) snprintf(err, err_cap, "bad binop st->stack at IR index %zu", i);
                    goto fail;
                }
                Expr *e = expr_new(EXPR_BINOP);
                if (!e) {
                    expr_free(rhs);
                    expr_free(lhs);
                    goto oom;
                }
                e->op_code = op_code;
                e->op_line0 = inst->has_arg2 ? inst->arg2 : -1;
                e->op_col0 = inst->has_arg3 ? inst->arg3 : -1;
                e->lhs = lhs;
                e->rhs = rhs;
                if (!stack_push(&st->stack, &st->stack_len, &st->stack_cap, e)) {
                    expr_free(e);
                    goto oom;
                }
            }
            continue;
    } while (0);
    RETURN_STATUS(IR2AEL_STATUS_HANDLED);
fail_emit:
    RETURN_STATUS(IR2AEL_STATUS_FAIL_EMIT);
oom:
    RETURN_STATUS(IR2AEL_STATUS_OOM);
fail:
    RETURN_STATUS(IR2AEL_STATUS_FAIL);
#undef RETURN_STATUS
}
