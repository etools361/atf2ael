/* autogenerated: flow handler */
#include "ir2ael_internal.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

Ir2AelStatus ir2ael_flow_handle_load_true(Ir2AelState *s, size_t *idx, const IRInst *inst) {
    if (!s || !inst || !idx) return IR2AEL_STATUS_FAIL;
    Ir2AelState *st = s;
    const IRProgram *program = s->program;
    AelEmitter *out = s->out;
    char *err = s->err;
    size_t err_cap = s->err_cap;
    size_t i = *idx;

#define RETURN_STATUS(_status) do { *idx = i; return (_status); } while (0)

    if (inst->op == OP_LOAD_TRUE) {
        do {
            /* If the for-header update was already emitted via assignment, ignore the scaffold LOAD_TRUE
               that precedes the loop-back BRANCH_TRUE (otherwise we leave a stray boolean on the st->stack). */
            if (st->for_hdr_sp > 0 && st->for_hdr_stack[st->for_hdr_sp - 1].stage == 3 &&
                i + 1 < program->count &&
                program->insts[i + 1].op == OP_BRANCH_TRUE &&
                program->insts[i + 1].has_arg2 && program->insts[i + 1].has_arg3 &&
                program->insts[i + 1].arg2 == st->for_hdr_stack[st->for_hdr_sp - 1].line0) {
                continue;
            }

            /* for-header update (generic expression): in many real baselines the update is a call, e.g.
               for (; cond; db_iter_get_next(iter)) { ... }
               The update expression is not followed by STMT_END; it is terminated by the trailing LOAD_TRUE
               that precedes the BRANCH_TRUE back to loop_start_label (at ')' position). */
            if (st->for_hdr_sp > 0 && st->for_hdr_stack[st->for_hdr_sp - 1].stage == 2 &&
                i + 1 < program->count &&
                program->insts[i + 1].op == OP_BRANCH_TRUE &&
                program->insts[i + 1].has_arg2 && program->insts[i + 1].has_arg3 &&
                program->insts[i + 1].arg2 == st->for_hdr_stack[st->for_hdr_sp - 1].line0) {

                Expr *upd = stack_pop(st->stack, &st->stack_len);
                stack_clear(st->stack, &st->stack_len);
                if (!upd) {
                    if (err && err_cap) snprintf(err, err_cap, "for without update expr at IR index %zu", i);
                    goto fail;
                }

                int line0 = st->for_hdr_stack[st->for_hdr_sp - 1].line0;
                int start_col0 = expr_start_col0(upd, line0);
                if (start_col0 < out->col0) start_col0 = out->col0;
                if (!ael_emit_at(out, line0, start_col0)) {
                    expr_free(upd);
                    goto fail_emit;
                }
                if (!emit_expr_addr(out, upd, 0)) {
                    expr_free(upd);
                    goto fail_emit;
                }
                expr_free(upd);

                st->for_hdr_stack[st->for_hdr_sp - 1].stage = 3; /* next: close ')' at STMT_END */
                continue;
            }

            /* Otherwise treat it as a boolean literal pushed onto the expression st->stack.
               This is required for patterns like: "do { ... } while (true);" where the
               compiler encodes the condition as LOAD_TRUE + BRANCH_TRUE start_label. */
            {
                Expr *e = expr_new(EXPR_BOOL);
                if (!e) goto oom;
                e->bool_value = (inst->has_arg1 ? (inst->arg1 != 0) : 1);
                if (!stack_push(&st->stack, &st->stack_len, &st->stack_cap, e)) {
                    expr_free(e);
                    goto oom;
                }
            }
            continue;
        } while (0);
        RETURN_STATUS(IR2AEL_STATUS_HANDLED);
    }

    RETURN_STATUS(IR2AEL_STATUS_NOT_HANDLED);
fail_emit:
    RETURN_STATUS(IR2AEL_STATUS_FAIL_EMIT);
oom:
    RETURN_STATUS(IR2AEL_STATUS_OOM);
fail:
    RETURN_STATUS(IR2AEL_STATUS_FAIL);
#undef RETURN_STATUS
}
