/* autogenerated: flow label handlers */
#include "ir2ael_internal.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

Ir2AelStatus ir2ael_flow_handle_add_label(Ir2AelState *s, size_t *idx, const IRInst *inst) {
    if (!s || !inst || !idx) return IR2AEL_STATUS_FAIL;
    Ir2AelState *st = s;
    const IRProgram *program = s->program;
    AelEmitter *out = s->out;
    char *err = s->err;
    size_t err_cap = s->err_cap;
    size_t i = *idx;

#define RETURN_STATUS(_status) do { *idx = i; return (_status); } while (0)

    if (inst->op == OP_ADD_LABEL) {
        do {
            /* else header: ADD_LABEL end, LOAD_TRUE (OP=7), BRANCH_TRUE end, SET_LABEL else */
            int ctx_idx = -1;
            for (int k = st->if_sp - 1; k >= 0; k--) {
                if (st->if_stack[k].stage == 1 && st->if_stack[k].depth == st->cur_depth) {
                    ctx_idx = k;
                    break;
                }
            }
            if (ctx_idx >= 0) st->if_sp = ctx_idx + 1;
            IfCtx *ctx = (st->if_sp > 0) ? &st->if_stack[st->if_sp - 1] : NULL;
            if (ctx && ctx->stage == 1 && i + 3 < program->count &&
                program->insts[i + 1].op == OP_LOAD_TRUE &&
                program->insts[i + 2].op == OP_BRANCH_TRUE && program->insts[i + 2].has_arg1 &&
                program->insts[i + 3].op == OP_SET_LABEL && program->insts[i + 3].has_arg1 &&
                program->insts[i + 3].arg1 == ctx->else_label) {

                const IRInst *br = &program->insts[i + 2];
                int end_label = br->arg1;
                int close_line0 = br->has_arg2 ? br->arg2 : out->line0;
                int close_col0 = br->has_arg3 ? br->arg3 : 0;
                bool brace_style = ctx->brace_style;
                if (brace_style) {
                    if (close_line0 < out->line0) {
                        close_line0 = out->line0;
                        close_col0 = decl_indent_col0_from_depth(st->cur_depth);
                    }
                    if (st->in_function && !anon_close_scopes_before_stmt(out, &st->anon_depth_sp, st->anon_depth_stack, ctx->depth + 1, close_line0)) goto fail_emit;
                    if (!ael_emit_at(out, close_line0, close_col0)) goto fail_emit;
                    if (!ael_emit_text(out, "}\n")) goto fail_emit;
                    anon_depth_pop_expected(&st->anon_depth_sp, st->anon_depth_stack, ctx->depth + 1, true);
                }

                int else_line0 = (brace_style || out->line0 <= close_line0) ? (close_line0 + 1) : out->line0;
                bool is_else_if = false;
                bool else_immediate_block = false;
                {
                    size_t body_start = i + 4;
                    if (body_start < program->count && program->insts[body_start].op == OP_NUM_LOCAL) {
                        else_immediate_block = true;
                    }
                }
                if (brace_style) {
                    /* Some real baselines encode BRANCH_TRUE positions near the else-if header rather than the
                       closing brace line, so close_line0+1 can be far from the next if-header. Prefer scanning
                       ahead for an if-header and using its recorded source line.

                       IMPORTANT: only treat it as else-if when the *first* statement in the else body is an if-header;
                       otherwise we can misclassify "else { stmt; if(...) ... }" and perturb label numbering. */
                    int found_if_line0 = -1;
                    bool saw_stmt = false;
                    size_t scan_end = i + 256;
                    if (scan_end > program->count) scan_end = program->count;
                    for (size_t j = i + 4; j < scan_end; j++) {
                        const IRInst *mj = &program->insts[j];
                        if (mj->op == OP_SET_LABEL && mj->has_arg1 && mj->arg1 == end_label) break;
                        if (mj->op == OP_BEGIN_FUNCT || mj->op == OP_DEFINE_FUNCT) break;
                        if (!saw_stmt && mj->op == OP_OP && mj->has_arg1 && mj->arg1 == 59) {
                            int scan_depth = out->strict_pos ? ctx->depth : -1;
                            if (ir_else_if_chain_at(program, j, program->count, scan_depth, end_label, &found_if_line0) && found_if_line0 >= 0) {
                                is_else_if = true;
                                else_line0 = found_if_line0;
                                break;
                            }
                        }
                        if (mj->op == OP_OP && mj->has_arg1 && mj->has_arg2) {
                            if (mj->arg1 == 20 ||
                                (mj->arg1 == 0 && !op0_is_short_circuit_marker(program, j, scan_end))) {
                                /* Only treat completed statements as blockers (avoid expr ops in if headers). */
                                saw_stmt = true;
                            }
                        }
                    }
                } else {
                    for (size_t j = i + 4; j + 3 < program->count && j < i + 256; j++) {
                        const IRInst *a = &program->insts[j];
                        if (a->op == OP_OP && a->has_arg1 && a->arg1 == 59 && a->has_arg2) {
                            int found_if_line0 = -1;
                            if (ir_else_if_chain_at(program, j, program->count, -1, end_label, &found_if_line0) && found_if_line0 >= 0) {
                                else_line0 = found_if_line0;
                                is_else_if = true;
                            }
                            break;
                        }
                        if (a->op == OP_OP && a->has_arg1 && a->arg1 == 20 && a->has_arg2) {
                            else_line0 = a->arg2 - 1;
                            if (else_line0 < 0) else_line0 = 0;
                            is_else_if = false;
                            break;
                        }
                        if (a->op == OP_SET_LABEL && a->has_arg1 && a->arg1 == end_label) {
                            break;
                        }
                    }
                }

                /* If the else-label is immediately followed by another label at the same-or-lower depth,
                   treat this as an empty-else fallthrough (do not form an else-if chain). */
                {
                    size_t body_start = i + 4;
                    if (body_start < program->count && program->insts[body_start].op == OP_SET_LABEL &&
                        program->insts[body_start].has_depth && program->insts[body_start].depth <= ctx->depth) {
                        is_else_if = false;
                    }
                }
                int else_col0 = ctx->depth * 4;
                if (!ael_emit_at(out, else_line0, else_col0)) goto fail_emit;

                /* Else-body can be either a brace block ("else { ... }") or a single statement ("else stmt;").
                   Even if the if-body is brace-style, baselines sometimes use "else;" without braces. */
                 bool else_has_block = false;
                 if (!is_else_if) {
                     /* Braced else blocks start with NUM_LOCAL immediately after SET_LABEL else_label.
                        Don't treat later nested NUM_LOCAL as evidence for "else { ... }", otherwise we
                         spuriously insert braces and ael2ir adds extra NUM_LOCAL/DROP_LOCAL. */
                     size_t body_start = i + 4;
                    else_has_block = else_body_has_brace_block(program, body_start, end_label, ctx->depth);
                 }

                bool else_body_empty = false;
                {
                    bool saw_stmt = false;
                    for (size_t j = i + 4; j < program->count && j < i + 512; j++) {
                        const IRInst *mj = &program->insts[j];
                        if (mj->op == OP_SET_LABEL && mj->has_arg1 && mj->arg1 == end_label) {
                            else_body_empty = !saw_stmt;
                            break;
                        }
                        if (mj->op == OP_BEGIN_FUNCT || mj->op == OP_DEFINE_FUNCT) {
                            else_body_empty = !saw_stmt;
                            break;
                        }
                        if (mj->op == OP_OP && mj->has_arg1 &&
                            (mj->arg1 == 0 || mj->arg1 == 16 || mj->arg1 == 20 || mj->arg1 == 48) &&
                            mj->has_arg2) {
                            saw_stmt = true;
                        }
                    }
                    /* If we hit the scan limit without seeing end_label, fall back to saw_stmt. */
                    if (!else_body_empty && !saw_stmt) else_body_empty = true;
                }

                /* When scope-block reconstruction is disabled, do not try to infer brace-ness from
                   NUM_LOCAL bookkeeping. Prefer braced else bodies for stability, since many baselines
                   use braces even for single-statement else. */
                if (!is_else_if && !else_body_empty && !out->allow_num_local_scope_blocks) {
                    else_has_block = true;
                }

                if (is_else_if) {
                    if (!ael_emit_text(out, "else ")) goto fail_emit;
                    st->pending_inline_else_if = true;
                    st->pending_inline_else_line0 = else_line0;
                    st->pending_inline_else_col0 = else_col0;
                    st->if_sp--; /* else-if ends the current if immediately */
                } else if (else_body_empty) {
                    /* Empty else body: emit 'else;' so the else-label/template stays parseable and roundtrips. */
                    if (!ael_emit_text(out, "else;\n")) goto fail_emit;
                    st->if_sp--;
                } else if (!else_has_block) {
                    /* Else is a single statement (no brace block). */
                    if (!ael_emit_text(out, "else\n")) goto fail_emit;
                    st->if_sp--;
                } else {
                    if (!(st->in_function || st->pending_defun)) {
                        if (!ael_emit_text(out, "else\n")) goto fail_emit;
                        if (!ael_emit_at(out, else_line0 + 1, else_col0)) goto fail_emit;
                        if (!ael_emit_text(out, "{\n")) goto fail_emit;
                    } else {
                        if (!ael_emit_text(out, "else {\n")) goto fail_emit;
                    }
                    (void)anon_depth_push_marked(&st->anon_depth_sp, st->anon_depth_stack, ctx->depth + 1, true);
                    ctx->else_brace_style = true;
                    ctx->end_label = end_label;
                    ctx->stage = 2;
                }

                i += 3; /* consume header ops (LOAD_TRUE, BRANCH_TRUE, SET_LABEL else) */
                continue;
            }
            continue;
        } while (0);
        RETURN_STATUS(IR2AEL_STATUS_HANDLED);
    }
    RETURN_STATUS(IR2AEL_STATUS_NOT_HANDLED);
fail_emit:
    RETURN_STATUS(IR2AEL_STATUS_FAIL_EMIT);
#undef RETURN_STATUS
}

Ir2AelStatus ir2ael_flow_handle_set_label(Ir2AelState *s, size_t *idx, const IRInst *inst) {
    if (!s || !inst || !idx) return IR2AEL_STATUS_FAIL;
    Ir2AelState *st = s;
    const IRProgram *program = s->program;
    AelEmitter *out = s->out;
    char *err = s->err;
    size_t err_cap = s->err_cap;
    size_t i = *idx;

#define RETURN_STATUS(_status) do { *idx = i; return (_status); } while (0)

    if (inst->op == OP_SET_LABEL) {
        do {
            if (st->loop_sp > 0 && inst->has_arg1) {
                LoopCtx *lctx = &st->loop_stack[st->loop_sp - 1];
                size_t next_idx = ir_skip_locals_bookkeeping(program, i + 1);
                /* Capture loop continue label when the template emits: LOOP_AGAIN, ADD_LABEL, SET_LABEL X */
                if ((lctx->kind == 2 || lctx->kind == 3) && lctx->continue_label < 0 &&
                    i >= 2 && program->insts[i - 1].op == OP_ADD_LABEL && program->insts[i - 2].op == OP_LOOP_AGAIN) {
                    lctx->continue_label = inst->arg1;
                }
                /* Capture loop end label near END_LOOP for templates that don't expose it earlier. */
                if ((lctx->kind == 2 || lctx->kind == 3) && lctx->end_label < 0 &&
                    next_idx < program->count && program->insts[next_idx].op == OP_END_LOOP) {
                    lctx->end_label = inst->arg1;
                }
                bool is_while_end = false;
                if (lctx->kind == 1 && lctx->end_label >= 0 && inst->arg1 == lctx->end_label) {
                    is_while_end = true;
                }
                /* Many baselines anchor loop end as: SET_LABEL end; END_LOOP. */
                if (!is_while_end && lctx->kind == 1 &&
                    next_idx < program->count && program->insts[next_idx].op == OP_END_LOOP) {
                    is_while_end = true;
                }
                if (is_while_end) {
                    if (st->in_function && !anon_close_scopes_before_stmt(out, &st->anon_depth_sp, st->anon_depth_stack, lctx->depth + 1, out->line0)) {
                        goto fail_emit;
                    }
                    if (!ael_emit_text(out, "}\n")) goto fail_emit;
                    anon_depth_pop_expected(&st->anon_depth_sp, st->anon_depth_stack, lctx->depth + 1, true);
                    st->loop_sp--;
                    continue;
                }
            }
            if (st->if_sp > 0 && inst->has_arg1) {
                int match_idx = -1;
                for (int k = st->if_sp - 1; k >= 0; k--) {
                    IfCtx *t = &st->if_stack[k];
                    if (t->stage == 1 && inst->arg1 == t->else_label) {
                        match_idx = k;
                        break;
                    }
                    if (t->stage == 2 && t->end_label >= 0 && inst->arg1 == t->end_label) {
                        match_idx = k;
                        break;
                    }
                }
                /* Some IR logs omit DEPTH annotations around SET_LABEL, so st->cur_depth can be stale here.
                   If we didn't find a match, fall back to matching by label id (innermost first). */
                if (match_idx < 0) {
                    for (int k = st->if_sp - 1; k >= 0; k--) {
                        IfCtx *t = &st->if_stack[k];
                        if (t->depth > st->cur_depth) continue;
                        if (t->stage == 1 && inst->arg1 == t->else_label) {
                            match_idx = k;
                            break;
                        }
                        if (t->stage == 2 && t->end_label >= 0 && inst->arg1 == t->end_label) {
                            match_idx = k;
                            break;
                        }
                    }
                }
                if (match_idx >= 0) st->if_sp = match_idx + 1;
                IfCtx *ctx = (st->if_sp > 0) ? &st->if_stack[st->if_sp - 1] : NULL;
                if (!ctx) continue;
                if (ctx->stage == 1 && inst->arg1 == ctx->else_label) {
                    /* If we know the end label, treat this as an explicit else branch (possibly empty),
                       even when the then-body used braces and the IR didn't include an ADD_LABEL else header. */
                    if (ctx->end_label >= 0) {
                        int else_col0 = ctx->depth * 4;

                        /* Close braced then-body before emitting else. */
                        if (ctx->brace_style) {
                            if (st->in_function && !anon_close_scopes_before_stmt(out, &st->anon_depth_sp, st->anon_depth_stack, ctx->depth + 1, out->line0)) goto fail_emit;
                            if (!ael_emit_text(out, "}\n")) goto fail_emit;
                            anon_depth_pop_expected(&st->anon_depth_sp, st->anon_depth_stack, ctx->depth + 1, true);
                        }

                        /* If the else-label is immediately followed by another label at the same-or-lower
                           depth, the else body is empty (label coalescing). Emit an explicit empty else to
                           preserve label/template structure, but do not try to form an else-if chain. */
                        if (i + 1 < program->count && program->insts[i + 1].op == OP_SET_LABEL && program->insts[i + 1].has_arg1) {
                            const IRInst *nxt = &program->insts[i + 1];
                            if (!nxt->has_depth || nxt->depth <= ctx->depth) {
                                if (!ael_emit_at(out, out->line0, else_col0)) goto fail_emit;
                                if (!ael_emit_text(out, "else;\n")) goto fail_emit;
                                st->if_sp--;
                                continue;
                            }
                        }

                        bool else_has_block = false;
                        bool else_body_empty = true;
                        bool else_is_else_if = false;
                        bool else_body_block = false;
                        int found_if_line0 = -1;

                        if (i + 1 < program->count && program->insts[i + 1].op == OP_NUM_LOCAL) {
                            else_body_block = true;
                        }

                        int else_line_hint = out->line0;
                        for (size_t j = i + 1; j < program->count && j < i + 512; j++) {
                            const IRInst *mj = &program->insts[j];
                            if (mj->op == OP_SET_LABEL && mj->has_arg1 && mj->arg1 == ctx->end_label) break;
                            if (mj->op == OP_BEGIN_FUNCT || mj->op == OP_DEFINE_FUNCT) break;

                            if (!else_is_else_if && else_body_empty && !else_body_block &&
                                mj->op == OP_OP && mj->has_arg1 && mj->arg1 == 59 && mj->has_arg2) {
                                /* Depth from ATF-derived IR can be noisy; only stop if we clearly left the parent depth. */
                                if (mj->has_depth && mj->depth < ctx->depth) break;
                                int scan_depth = out->strict_pos ? ctx->depth : -1;
                                if (!ir_else_if_chain_at(program, j, program->count, scan_depth, ctx->end_label, &found_if_line0) || found_if_line0 < 0) {
                                    continue;
                                }
                                if (mj->arg2 > else_line_hint + 1) {
                                    continue;
                                }
                                else_is_else_if = true;
                                break;
                            }
                            if (mj->op == OP_OP && mj->has_arg1 &&
                                (mj->arg1 == 0 || mj->arg1 == 16 || mj->arg1 == 20 || mj->arg1 == 48) &&
                                mj->has_arg2) {
                                else_body_empty = false;
                            }
                        }
                        if (!ael_emit_at(out, out->line0, else_col0)) goto fail_emit;
                        if (else_is_else_if && found_if_line0 >= 0) {
                            if (found_if_line0 < out->line0) found_if_line0 = out->line0;
                            if (!ael_emit_at(out, found_if_line0, else_col0)) goto fail_emit;
                            if (!ael_emit_text(out, "else ")) goto fail_emit;
                            st->pending_inline_else_if = true;
                            st->pending_inline_else_line0 = found_if_line0;
                            st->pending_inline_else_col0 = else_col0;
                            st->if_sp--; /* else-if ends the current if immediately */
                            continue;
                        }
                        if (else_body_empty) {
                            if (!ael_emit_text(out, "else;\n")) goto fail_emit;
                            st->if_sp--;
                            continue;
                        }

                         /* Braced else blocks start with NUM_LOCAL immediately after SET_LABEL else_label. */
                        else_has_block = else_body_has_brace_block(program, i + 1, ctx->end_label, ctx->depth);

                        if (else_has_block) {
                            if (!(st->in_function || st->pending_defun)) {
                                if (!ael_emit_text(out, "else\n")) goto fail_emit;
                                if (!ael_emit_at(out, out->line0 + 1, else_col0)) goto fail_emit;
                                if (!ael_emit_text(out, "{\n")) goto fail_emit;
                            } else {
                                if (!ael_emit_text(out, "else {\n")) goto fail_emit;
                            }
                            (void)anon_depth_push_marked(&st->anon_depth_sp, st->anon_depth_stack, ctx->depth + 1, true);
                            ctx->else_brace_style = true;
                        } else {
                            if (!ael_emit_text(out, "else\n")) goto fail_emit;
                            ctx->else_brace_style = false;
                        }
                        ctx->stage = 2;
                        continue;
                    }
                    /* No-brace else block: emit 'else' at the line before the first statement in else. */
                    if (!ctx->brace_style && ctx->end_label >= 0) {
                        int else_line0 = -1;
                        int found_if_line0 = -1;
                        bool else_inline = false;
                        for (size_t j = i + 1; j < program->count && j < i + 256; j++) {
                            const IRInst *mj = &program->insts[j];
                            if (mj->op == OP_SET_LABEL && mj->has_arg1 && mj->arg1 == ctx->end_label) break;
                            if (mj->op == OP_OP && mj->has_arg1 && mj->has_arg2 &&
                                (mj->arg1 == 59 || mj->arg1 == 20 || mj->arg1 == 16)) {
                                if (mj->arg1 == 59) {
                                    found_if_line0 = mj->arg2;
                                } else if (mj->arg1 == 20) {
                                    else_line0 = mj->arg2;
                                    else_inline = true;
                                } else {
                                    else_line0 = mj->arg2 - 1;
                                }
                                break;
                            }
                        }
                        int else_col0 = ctx->depth * 4;
                        if (found_if_line0 >= 0) {
                            if (found_if_line0 < out->line0) found_if_line0 = out->line0;
                            if (!ael_emit_at(out, found_if_line0, else_col0)) goto fail_emit;
                            if (!ael_emit_text(out, "else ")) goto fail_emit;
                            st->pending_inline_else_if = true;
                            st->pending_inline_else_line0 = found_if_line0;
                            st->pending_inline_else_col0 = else_col0;
                            st->if_sp--; /* else-if ends the current if immediately */
                            continue;
                        }
                        if (else_line0 < 0) else_line0 = out->line0;
                        if (else_line0 < out->line0) else_line0 = out->line0;
                        if (!ael_emit_at(out, else_line0, else_col0)) goto fail_emit;
                        bool else_has_block = false;
                        bool else_body_empty = true;
                        for (size_t j = i + 1; j < program->count && j < i + 512; j++) {
                            const IRInst *mj = &program->insts[j];
                            if (mj->op == OP_SET_LABEL && mj->has_arg1 && mj->arg1 == ctx->end_label) break;
                            if (mj->op == OP_OP && mj->has_arg1 &&
                                (mj->arg1 == 0 || mj->arg1 == 16 || mj->arg1 == 20 || mj->arg1 == 48)) {
                                else_body_empty = false;
                                break;
                            }
                        }
                        else_has_block = else_body_has_brace_block(program, i + 1, ctx->end_label, ctx->depth);

                        if (!else_inline && else_body_empty) {
                            if (!ael_emit_text(out, "else;\n")) goto fail_emit;
                            st->if_sp--;
                            continue;
                        }
                        if (!else_inline && else_has_block) {
                            if (!ael_emit_text(out, "else\n")) goto fail_emit;
                            if (!ael_emit_at(out, else_line0 + 1, else_col0)) goto fail_emit;
                            if (!ael_emit_text(out, "{\n")) goto fail_emit;
                            (void)anon_depth_push_marked(&st->anon_depth_sp, st->anon_depth_stack, ctx->depth + 1, true);
                            ctx->else_brace_style = true;
                            ctx->stage = 2;
                            continue;
                        }

                        if (!ael_emit_text(out, else_inline ? "else " : "else\n")) goto fail_emit;
                        ctx->stage = 2;
                        continue;
                    }
                    /* Some no-brace templates start the else block at SET_LABEL without an ADD_LABEL header. */
                    if (!ctx->brace_style && ctx->end_label < 0) {
                        int inferred_end_label = -1;
                        size_t k_start = (i > 12) ? (i - 12) : 0;
                        for (size_t k = i; k > k_start; k--) {
                            const IRInst *mj = &program->insts[k];
                            const IRInst *prev = &program->insts[k - 1];
                            if (prev->op == OP_LOAD_TRUE && mj->op == OP_BRANCH_TRUE && mj->has_arg1) {
                                inferred_end_label = mj->arg1;
                                break;
                            }
                        }
                        if (inferred_end_label >= 0 && inferred_end_label != ctx->else_label) {
                            int else_line0 = -1;
                            int found_if_line0 = -1;
                            bool else_inline = false;
                            for (size_t j = i + 1; j < program->count && j < i + 256; j++) {
                                const IRInst *mj = &program->insts[j];
                                if (mj->op == OP_SET_LABEL && mj->has_arg1 && mj->arg1 == inferred_end_label) break;
                                if (mj->op == OP_OP && mj->has_arg1 && mj->has_arg2 &&
                                    (mj->arg1 == 59 || mj->arg1 == 20 || mj->arg1 == 16)) {
                                    if (mj->arg1 == 59) {
                                        found_if_line0 = mj->arg2;
                                    } else if (mj->arg1 == 20) {
                                        else_line0 = mj->arg2;
                                        else_inline = true;
                                    } else {
                                        else_line0 = mj->arg2 - 1;
                                    }
                                    break;
                                }
                            }
                            int else_col0 = ctx->depth * 4;
                            if (found_if_line0 >= 0) {
                                if (found_if_line0 < out->line0) found_if_line0 = out->line0;
                                if (!ael_emit_at(out, found_if_line0, else_col0)) goto fail_emit;
                                if (!ael_emit_text(out, "else ")) goto fail_emit;
                                st->pending_inline_else_if = true;
                                st->pending_inline_else_line0 = found_if_line0;
                                st->pending_inline_else_col0 = else_col0;
                                st->if_sp--; /* else-if ends the current if immediately */
                                continue;
                            }
                            if (else_line0 < 0) else_line0 = out->line0;
                            if (else_line0 < out->line0) else_line0 = out->line0;
                            if (!ael_emit_at(out, else_line0, else_col0)) goto fail_emit;
                            if (!ael_emit_text(out, else_inline ? "else " : "else\n")) goto fail_emit;
                            ctx->end_label = inferred_end_label;
                            ctx->stage = 2;
                            continue;
                        }
                    }
                    /* if without else: close then block */
                    if (ctx->brace_style) {
                        if (st->in_function && !anon_close_scopes_before_stmt(out, &st->anon_depth_sp, st->anon_depth_stack, ctx->depth + 1, out->line0)) goto fail_emit;
                        if (!ael_emit_text(out, "}\n")) goto fail_emit;
                        anon_depth_pop_expected(&st->anon_depth_sp, st->anon_depth_stack, ctx->depth + 1, true);
                    }
                    st->if_sp--;
                    continue;
                }
                if (ctx->stage == 2 && ctx->end_label >= 0 && inst->arg1 == ctx->end_label) {
                    /* end of else block */
                    if (ctx->else_brace_style) {
                        if (st->in_function && !anon_close_scopes_before_stmt(out, &st->anon_depth_sp, st->anon_depth_stack, ctx->depth + 1, out->line0)) goto fail_emit;
                        if (!ael_emit_text(out, "}\n")) goto fail_emit;
                        anon_depth_pop_expected(&st->anon_depth_sp, st->anon_depth_stack, ctx->depth + 1, true);
                    }
                    st->if_sp--;
                    continue;
                }
            }
            continue;
        } while (0);
        RETURN_STATUS(IR2AEL_STATUS_HANDLED);
    }
    RETURN_STATUS(IR2AEL_STATUS_NOT_HANDLED);
fail_emit:
    RETURN_STATUS(IR2AEL_STATUS_FAIL_EMIT);
#undef RETURN_STATUS
}
