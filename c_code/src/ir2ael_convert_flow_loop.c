/* autogenerated: flow handler */
#include "ir2ael_internal.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

Ir2AelStatus ir2ael_flow_handle_begin_loop(Ir2AelState *s, size_t *idx, const IRInst *inst) {
    if (!s || !inst || !idx) return IR2AEL_STATUS_FAIL;
    Ir2AelState *st = s;
    const IRProgram *program = s->program;
    AelEmitter *out = s->out;
    char *err = s->err;
    size_t err_cap = s->err_cap;
    size_t i = *idx;

#define RETURN_STATUS(_status) do { *idx = i; return (_status); } while (0)

    if (inst->op == OP_BEGIN_LOOP) {
        do {
            /* switch pattern begins with: <expr>, OP=17, BEGIN_LOOP, LOAD_TRUE, LOOP_AGAIN ... */
            if (!st->sw.active && i > 0 && st->stack_len > 0 &&
                program->insts[i - 1].op == OP_OP && program->insts[i - 1].has_arg1 && program->insts[i - 1].arg1 == 17 &&
                i + 2 < program->count &&
                program->insts[i + 1].op == OP_LOAD_TRUE &&
                program->insts[i + 2].op == OP_LOOP_AGAIN) {

                Expr *sw_expr = stack_pop(st->stack, &st->stack_len);
                stack_clear(st->stack, &st->stack_len);
                if (!sw_expr) {
                    if (err && err_cap) snprintf(err, err_cap, "switch without expression at IR index %zu", i);
                    goto fail;
                }

                int line0 = program->insts[i - 1].has_arg2 ? program->insts[i - 1].arg2 : out->line0;
                int lparen_col0 = (program->insts[i - 1].has_arg3 && program->insts[i - 1].arg3 > 0) ? (program->insts[i - 1].arg3 - 1) : 7;
                int switch_col0 = lparen_col0 - 7; /* strlen("switch ") */
                if (switch_col0 < 0) switch_col0 = 0;

                if (!out->strict_pos) {
                    line0 = out->line0;
                    switch_col0 = decl_indent_col0_from_depth(st->cur_depth);
                }

                if (!ael_emit_at(out, line0, switch_col0)) {
                    expr_free(sw_expr);
                    goto fail_emit;
                }
                if (!ael_emit_text(out, "switch ")) {
                    expr_free(sw_expr);
                    goto fail_emit;
                }
                if (out->strict_pos) {
                    if (!ael_emit_at(out, line0, lparen_col0)) {
                        expr_free(sw_expr);
                        goto fail_emit;
                    }
                }
                if (!ael_emit_char(out, '(')) {
                    expr_free(sw_expr);
                    goto fail_emit;
                }
                if (!emit_expr_addr(out, sw_expr, 0)) {
                    expr_free(sw_expr);
                    goto fail_emit;
                }
                expr_free(sw_expr);
                if (!ael_emit_text(out, ")")) goto fail_emit;

                st->sw.active = true;
                st->sw.line0 = line0;
                st->sw.col0 = switch_col0;
                st->sw.depth = st->cur_depth;
                st->sw.opened = false;
                st->sw.pending_case_kind = 0;
                st->sw.pending_case_value = 0;
                st->sw.pending_case_emitted = true;
                st->sw.table_label = -1;
                st->sw.has_end_label = false;
                st->sw.end_label = -1;
                st->sw.last_break_line0 = -1;

                /* Learn the BRANCH_TABLE entry label (SET_LABEL just before OP_BRANCH_TABLE). */
                for (size_t j = i; j < program->count && j < i + 256; j++) {
                    if (program->insts[j].op == OP_BRANCH_TABLE) {
                        if (j > 0 && program->insts[j - 1].op == OP_SET_LABEL && program->insts[j - 1].has_arg1) {
                            st->sw.table_label = program->insts[j - 1].arg1;
                        }
                        break;
                    }
                }

                /* In non-strict mode, open the switch block immediately for stability. */
                if (!out->strict_pos) {
                    if (!ael_emit_text(out, " {\n")) goto fail_emit;
                    st->sw.opened = true;
                    (void)anon_depth_push_marked(&st->anon_depth_sp, st->anon_depth_stack, st->sw.depth + 1, true);
                }

                continue;
            }

            /* do-while pattern begins with: ADD_LABEL L, BEGIN_LOOP, SET_LABEL L */
            if (i > 0 && i + 1 < program->count &&
                program->insts[i - 1].op == OP_ADD_LABEL &&
                program->insts[i + 1].op == OP_SET_LABEL && program->insts[i + 1].has_arg1 &&
                i + 2 < program->count && program->insts[i + 2].op == OP_NUM_LOCAL) {
                bool skip_do_while = (st->for_hdr_sp > 0);
                if (!skip_do_while) {
                    int start_label = program->insts[i + 1].arg1;
                    if (begin_loop_has_for_scaffold(program, i, start_label)) {
                        skip_do_while = true;
                    }
                }
                if (skip_do_while) {
                    /* For/iter-style loop scaffold; do not misclassify as do-while. */
                } else {
                if (st->loop_sp < (int)(sizeof(st->loop_stack) / sizeof(st->loop_stack[0]))) {
                    st->loop_stack[st->loop_sp].kind = 2; /* do-while */
                    st->loop_stack[st->loop_sp].depth = st->cur_depth;
                    st->loop_stack[st->loop_sp].start_label = program->insts[i + 1].arg1;
                    st->loop_stack[st->loop_sp].continue_label = -1;
                    st->loop_stack[st->loop_sp].end_label = -1;
                    st->loop_stack[st->loop_sp].while_line0 = -1;
                    st->loop_stack[st->loop_sp].while_col0 = -1;
                    st->loop_stack[st->loop_sp].cond_rparen_col0 = -1;
                    st->loop_stack[st->loop_sp].header_line0 = -1;
                    st->loop_stack[st->loop_sp].header_col0 = -1;
                    st->loop_stack[st->loop_sp].header_emitted = false;

                    /* Scan ahead for the trailing BRANCH_TRUE back to start_label to learn 'while' position. */
                    for (size_t j = i + 1; j < program->count && j < i + 256; j++) {
                        const IRInst *mj = &program->insts[j];
                        if (mj->op == OP_BRANCH_TRUE && mj->has_arg1 &&
                            mj->arg1 == st->loop_stack[st->loop_sp].start_label &&
                            mj->has_arg2 && mj->has_arg3) {
                            st->loop_stack[st->loop_sp].while_line0 = mj->arg2;
                            st->loop_stack[st->loop_sp].while_col0 = mj->arg3;
                            break;
                        }
                    }
                    st->loop_sp++;
                }
                }
            }

            /* while pattern begins with: BEGIN_LOOP, LOOP_AGAIN, ADD_LABEL, SET_LABEL start */
            if (i + 3 < program->count &&
                program->insts[i + 1].op == OP_LOOP_AGAIN &&
                program->insts[i + 2].op == OP_ADD_LABEL &&
                program->insts[i + 3].op == OP_SET_LABEL && program->insts[i + 3].has_arg1) {
                if (st->loop_sp < (int)(sizeof(st->loop_stack) / sizeof(st->loop_stack[0]))) {
                    st->loop_stack[st->loop_sp].kind = 1; /* while */
                    st->loop_stack[st->loop_sp].depth = st->cur_depth;
                    st->loop_stack[st->loop_sp].start_label = program->insts[i + 3].arg1;
                    st->loop_stack[st->loop_sp].continue_label = program->insts[i + 3].arg1; /* continue targets start */
                    st->loop_stack[st->loop_sp].end_label = -1;
                    st->loop_stack[st->loop_sp].while_line0 = -1;
                    st->loop_stack[st->loop_sp].while_col0 = -1;
                    st->loop_stack[st->loop_sp].cond_rparen_col0 = -1;
                    st->loop_stack[st->loop_sp].header_line0 = -1;
                    st->loop_stack[st->loop_sp].header_col0 = -1;
                    st->loop_stack[st->loop_sp].header_emitted = false;
                    st->loop_sp++;
                }
                continue;
            }
            continue;
        } while (0);
        RETURN_STATUS(IR2AEL_STATUS_HANDLED);
    }
    RETURN_STATUS(IR2AEL_STATUS_NOT_HANDLED);
fail_emit:
    RETURN_STATUS(IR2AEL_STATUS_FAIL_EMIT);
fail:
    RETURN_STATUS(IR2AEL_STATUS_FAIL);
#undef RETURN_STATUS
}
