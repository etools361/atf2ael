/* autogenerated: flow handler */
#include "ir2ael_internal.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

static Ir2AelStatus emit_while_header_common(Ir2AelState *st, int line0, int lparen_col0, Expr *cond, bool align_rparen, int *out_rparen_col0) {
    if (!st || !st->out || !cond) return IR2AEL_STATUS_FAIL;
    AelEmitter *out = st->out;
    int while_col0 = lparen_col0 - 6; /* strlen("while ") */
    if (while_col0 < 0) while_col0 = 0;

    if (!ael_emit_at(out, line0, while_col0)) return IR2AEL_STATUS_FAIL_EMIT;
    if (!ael_emit_text(out, "while ")) return IR2AEL_STATUS_FAIL_EMIT;
    if (!ael_emit_at(out, line0, lparen_col0)) return IR2AEL_STATUS_FAIL_EMIT;
    if (!ael_emit_char(out, '(')) return IR2AEL_STATUS_FAIL_EMIT;
    if (!emit_expr_addr(out, cond, 0)) return IR2AEL_STATUS_FAIL_EMIT;

    int rparen_col0 = out->col0;
    if (align_rparen) {
        if (rparen_col0 < lparen_col0 + 1) rparen_col0 = lparen_col0 + 1;
        if (!ael_emit_at(out, line0, rparen_col0)) return IR2AEL_STATUS_FAIL_EMIT;
    }

    if (st->in_function || st->pending_defun) {
        if (!ael_emit_text(out, ") {\n")) return IR2AEL_STATUS_FAIL_EMIT;
    } else {
        if (!ael_emit_text(out, ")\n")) return IR2AEL_STATUS_FAIL_EMIT;
        if (!ael_emit_at(out, line0 + 1, while_col0)) return IR2AEL_STATUS_FAIL_EMIT;
        if (!ael_emit_text(out, "{\n")) return IR2AEL_STATUS_FAIL_EMIT;
    }

    if (out_rparen_col0) *out_rparen_col0 = align_rparen ? rparen_col0 : out->col0;
    return IR2AEL_STATUS_HANDLED;
}

static Ir2AelStatus handle_branch_true_while_header_terminator(Ir2AelState *st, size_t i, const IRInst *inst) {
    if (!st || !inst) return IR2AEL_STATUS_FAIL;
    const IRProgram *program = st->program;
    char *err = st->err;
    size_t err_cap = st->err_cap;

    if (!(st->loop_sp > 0 && st->loop_stack[st->loop_sp - 1].kind == 1 &&
          !st->loop_stack[st->loop_sp - 1].header_emitted &&
          inst->has_arg1 && inst->has_arg2 && inst->has_arg3 &&
          i >= 3 &&
          program->insts[i - 1].op == OP_ADD_LABEL &&
          program->insts[i - 2].op == OP_LOOP_EXIT &&
          program->insts[i - 3].op == OP_OP && program->insts[i - 3].has_arg1 && program->insts[i - 3].arg1 == 3)) {
        return IR2AEL_STATUS_NOT_HANDLED;
    }

    LoopCtx *lctx = &st->loop_stack[st->loop_sp - 1];
    int line0 = inst->arg2;
    int lparen_col0 = inst->arg3;
    int rparen_col0 = -1;

    Expr *cond = (st->stack_len > 0) ? stack_pop(st->stack, &st->stack_len) : NULL;
    if (!cond) {
        if (err && err_cap) snprintf(err, err_cap, "while without condition at IR index %zu", i);
        return IR2AEL_STATUS_FAIL;
    }
    cond = unwrap_logical_not(cond);

    Ir2AelStatus emit_status = emit_while_header_common(st, line0, lparen_col0, cond, true, &rparen_col0);
    expr_free(cond);
    if (emit_status != IR2AEL_STATUS_HANDLED) return emit_status;

    lctx->end_label = inst->arg1;
    lctx->depth = st->cur_depth;
    lctx->header_line0 = line0;
    lctx->header_col0 = lparen_col0;
    lctx->cond_rparen_col0 = rparen_col0;
    lctx->header_emitted = true;
    (void)anon_depth_push_marked(&st->anon_depth_sp, st->anon_depth_stack, st->cur_depth + 1, true);

    stack_clear(st->stack, &st->stack_len);
    return IR2AEL_STATUS_HANDLED;
}

static Ir2AelStatus handle_branch_true_for_header_empty_init(Ir2AelState *st, size_t i, const IRInst *inst) {
    if (!st || !inst) return IR2AEL_STATUS_FAIL;
    const IRProgram *program = st->program;
    AelEmitter *out = st->out;
    char *err = st->err;
    size_t err_cap = st->err_cap;

    if (!(st->for_hdr_sp == 0 && inst->has_arg1 && inst->has_arg2 && inst->has_arg3 &&
          i >= 1 && program->insts[i - 1].op == OP_ADD_LABEL)) {
        return IR2AEL_STATUS_NOT_HANDLED;
    }

    /* Allow optional NUM_LOCAL/DROP_LOCAL between these ops (ATF-derived IR often inserts them). */
    size_t idx_load_true = ir_skip_locals_bookkeeping(program, i + 1);
    size_t idx_loop_exit =
        (idx_load_true < program->count && program->insts[idx_load_true].op == OP_LOAD_TRUE)
            ? ir_skip_locals_bookkeeping(program, idx_load_true + 1)
            : program->count;
    size_t idx_add_label2 =
        (idx_loop_exit < program->count && program->insts[idx_loop_exit].op == OP_LOOP_EXIT)
            ? ir_skip_locals_bookkeeping(program, idx_loop_exit + 1)
            : program->count;
    size_t idx_branch_end =
        (idx_add_label2 < program->count && program->insts[idx_add_label2].op == OP_ADD_LABEL)
            ? ir_skip_locals_bookkeeping(program, idx_add_label2 + 1)
            : program->count;
    size_t idx_loop_again =
        (idx_branch_end < program->count && program->insts[idx_branch_end].op == OP_BRANCH_TRUE &&
         program->insts[idx_branch_end].has_arg1)
            ? ir_skip_locals_bookkeeping(program, idx_branch_end + 1)
            : program->count;
    size_t idx_add_label3 =
        (idx_loop_again < program->count && program->insts[idx_loop_again].op == OP_LOOP_AGAIN)
            ? ir_skip_locals_bookkeeping(program, idx_loop_again + 1)
            : program->count;
    size_t idx_set_label_incr =
        (idx_add_label3 < program->count && program->insts[idx_add_label3].op == OP_ADD_LABEL)
            ? ir_skip_locals_bookkeeping(program, idx_add_label3 + 1)
            : program->count;

    if (idx_set_label_incr >= program->count ||
        program->insts[idx_set_label_incr].op != OP_SET_LABEL || !program->insts[idx_set_label_incr].has_arg1) {
        return IR2AEL_STATUS_NOT_HANDLED;
    }

    int line0 = inst->arg2;
    int semi2_col0 = inst->arg3;
    int incr_label = program->insts[idx_set_label_incr].arg1;
    int loop_label2 = program->insts[idx_branch_end].arg1;
    Expr *cond = stack_pop(st->stack, &st->stack_len);
    Expr *init = NULL;
    if (st->stack_len > 0) {
        Expr *candidate = stack_pop(st->stack, &st->stack_len);
        if (candidate && candidate->kind != EXPR_CALLARGS) {
            int init_line0 = candidate->op_line0;
            if (init_line0 < 0) init_line0 = expr_min_line0(candidate);
            if (init_line0 < 0 || init_line0 == line0) {
                init = candidate;
            } else {
                expr_free(candidate);
            }
        } else {
            expr_free(candidate);
        }
    }
    stack_clear(st->stack, &st->stack_len);
    if (!cond) {
        if (err && err_cap) snprintf(err, err_cap, "for without condition at IR index %zu", i);
        return IR2AEL_STATUS_FAIL;
    }

    int lparen_col0 = -1;
    if (!find_for_header_lparen_col0(program, i, 4096, line0, incr_label, loop_label2, &lparen_col0)) {
        lparen_col0 = semi2_col0 - 6;
        if (lparen_col0 < 0) lparen_col0 = 0;
    }

    int for_col0 = lparen_col0 - 4; /* prefer "for (" */
    if (for_col0 < 0) for_col0 = 0;

    int cond_start_col0 = expr_start_col0(cond, line0);
    if (cond_start_col0 < 0) cond_start_col0 = lparen_col0 + 3;
    int semi1_col0 = cond_start_col0 - 2;
    if (semi1_col0 < lparen_col0 + 1) semi1_col0 = lparen_col0 + 1;

    if (!ael_emit_at(out, line0, for_col0)) {
        expr_free(cond);
        return IR2AEL_STATUS_FAIL_EMIT;
    }
    if (!ael_emit_text(out, "for ")) {
        expr_free(cond);
        return IR2AEL_STATUS_FAIL_EMIT;
    }
    if (!ael_emit_at(out, line0, lparen_col0)) {
        expr_free(cond);
        return IR2AEL_STATUS_FAIL_EMIT;
    }
    if (!ael_emit_char(out, '(')) {
        expr_free(cond);
        return IR2AEL_STATUS_FAIL_EMIT;
    }
    if (init) {
        int init_col0 = expr_start_col0(init, line0);
        if (init_col0 < lparen_col0 + 1) init_col0 = lparen_col0 + 1;
        if (!ael_emit_at(out, line0, init_col0)) {
            expr_free(init);
            expr_free(cond);
            return IR2AEL_STATUS_FAIL_EMIT;
        }
        if (!emit_expr_addr(out, init, 0)) {
            expr_free(init);
            expr_free(cond);
            return IR2AEL_STATUS_FAIL_EMIT;
        }
        expr_free(init);
        if (semi1_col0 < out->col0) semi1_col0 = out->col0;
    }

    if (!ael_emit_at(out, line0, semi1_col0)) {
        expr_free(cond);
        return IR2AEL_STATUS_FAIL_EMIT;
    }
    if (!ael_emit_text(out, "; ")) {
        expr_free(cond);
        return IR2AEL_STATUS_FAIL_EMIT;
    }

    if (cond_start_col0 < out->col0) cond_start_col0 = out->col0;
    if (!ael_emit_at(out, line0, cond_start_col0)) {
        expr_free(cond);
        return IR2AEL_STATUS_FAIL_EMIT;
    }
    if (!emit_expr_addr(out, cond, 0)) {
        expr_free(cond);
        return IR2AEL_STATUS_FAIL_EMIT;
    }
    expr_free(cond);

    if (!ael_emit_at(out, line0, semi2_col0)) return IR2AEL_STATUS_FAIL_EMIT;
    if (!ael_emit_text(out, "; ")) return IR2AEL_STATUS_FAIL_EMIT;

    if (st->for_hdr_sp < (int)(sizeof(st->for_hdr_stack) / sizeof(st->for_hdr_stack[0]))) {
        st->for_hdr_stack[st->for_hdr_sp].line0 = line0;
        st->for_hdr_stack[st->for_hdr_sp].cond_start_col0 = semi2_col0 + 2;
        st->for_hdr_stack[st->for_hdr_sp].stage = 2; /* next: update */
        st->for_hdr_sp++;
    } else {
        if (err && err_cap) snprintf(err, err_cap, "for header stack overflow at IR index %zu", i);
        return IR2AEL_STATUS_FAIL;
    }

    if (st->loop_sp < (int)(sizeof(st->loop_stack) / sizeof(st->loop_stack[0]))) {
        st->loop_stack[st->loop_sp].kind = 3; /* for */
        st->loop_stack[st->loop_sp].depth = st->cur_depth;
        st->loop_stack[st->loop_sp].start_label = -1;
        st->loop_stack[st->loop_sp].continue_label = -1;
        st->loop_stack[st->loop_sp].end_label = -1;
        st->loop_stack[st->loop_sp].header_line0 = line0;
        st->loop_stack[st->loop_sp].header_col0 = lparen_col0;
        st->loop_stack[st->loop_sp].cond_rparen_col0 = -1;
        st->loop_stack[st->loop_sp].header_emitted = true;
        st->loop_stack[st->loop_sp].body_has_brace = false;
        st->loop_sp++;
    }

    return IR2AEL_STATUS_HANDLED;
}

static Ir2AelStatus handle_branch_true_braced_else_transition(Ir2AelState *st, size_t *idx, const IRInst *inst) {
    if (!st || !idx || !inst) return IR2AEL_STATUS_FAIL;
    const IRProgram *program = st->program;
    AelEmitter *out = st->out;
    size_t i = *idx;

    if (!(st->if_sp > 0 && inst->has_arg1 && i >= 1 && program->insts[i - 1].op == OP_LOAD_TRUE &&
          i + 1 < program->count && program->insts[i + 1].op == OP_SET_LABEL && program->insts[i + 1].has_arg1)) {
        return IR2AEL_STATUS_NOT_HANDLED;
    }

    IfCtx *ctx = &st->if_stack[st->if_sp - 1];
    if (!(ctx->stage == 1 && program->insts[i + 1].arg1 == ctx->else_label)) {
        return IR2AEL_STATUS_NOT_HANDLED;
    }

    if (ctx->end_label < 0) ctx->end_label = inst->arg1;

    /* If the else-label is immediately followed by another label at the same-or-lower
       depth, treat it as an empty-else fallthrough and do not form an else-if chain. */
    if (i + 2 < program->count && program->insts[i + 2].op == OP_SET_LABEL &&
        program->insts[i + 2].has_depth && program->insts[i + 2].depth <= ctx->depth) {
        int indent_col0 = ctx->depth * 4;
        if (ctx->brace_style) {
            if (!ael_emit_at(out, out->line0, indent_col0)) return IR2AEL_STATUS_FAIL_EMIT;
            if (!ael_emit_text(out, "}\n")) return IR2AEL_STATUS_FAIL_EMIT;
            anon_depth_pop_expected(&st->anon_depth_sp, st->anon_depth_stack, ctx->depth + 1, true);
        }
        if (!ael_emit_at(out, out->line0, indent_col0)) return IR2AEL_STATUS_FAIL_EMIT;
        if (!ael_emit_text(out, "else;\n")) return IR2AEL_STATUS_FAIL_EMIT;
        st->if_sp--;
        *idx = i + 1; /* consume SET_LABEL else_label */
        return IR2AEL_STATUS_HANDLED;
    }

    /* Else-if chains sometimes omit the ADD_LABEL header and jump directly into the next if.
       Only treat it as else-if when the *first* statement in the else body is an if-header. */
    int found_if_line0 = -1;
    {
        bool saw_stmt = false;
        for (size_t j = i + 2; j < program->count && j < i + 512; j++) {
            const IRInst *mj = &program->insts[j];
            if (mj->op == OP_SET_LABEL && mj->has_arg1 && mj->arg1 == ctx->end_label) break;
            if (mj->op == OP_BEGIN_FUNCT || mj->op == OP_DEFINE_FUNCT) break;
            if (mj->op == OP_OP && mj->has_arg1 && mj->has_arg2) {
                if (mj->arg1 == 20 ||
                    (mj->arg1 == 0 && !op0_is_short_circuit_marker(program, j, program->count))) {
                    /* Only treat completed statements as blockers (avoid expr ops in if headers). */
                    saw_stmt = true;
                }
            }
            if (mj->op == OP_OP && mj->has_arg1 && mj->arg1 == 59 && mj->has_arg2) {
                if (mj->has_depth && mj->depth < ctx->depth) break;
                if (!saw_stmt) found_if_line0 = mj->arg2;
                break;
            }
        }
    }
    if (found_if_line0 >= 0) {
        int indent_col0 = ctx->depth * 4;

        if (ctx->brace_style) {
            int close_line0 = found_if_line0 - 1;
            if (close_line0 < out->line0) close_line0 = out->line0;

            if (!ael_emit_at(out, close_line0, indent_col0)) return IR2AEL_STATUS_FAIL_EMIT;
            if (!ael_emit_text(out, "}\n")) return IR2AEL_STATUS_FAIL_EMIT;
            anon_depth_pop_expected(&st->anon_depth_sp, st->anon_depth_stack, ctx->depth + 1, true);
        }

        if (!ael_emit_at(out, found_if_line0, indent_col0)) return IR2AEL_STATUS_FAIL_EMIT;
        if (!ael_emit_text(out, "else ")) return IR2AEL_STATUS_FAIL_EMIT;

        st->pending_inline_else_if = true;
        st->pending_inline_else_line0 = found_if_line0;
        st->pending_inline_else_col0 = indent_col0;
        st->if_sp--; /* else-if ends the current if immediately */

        *idx = i + 1; /* consume SET_LABEL else_label */
        return IR2AEL_STATUS_HANDLED;
    }

    /* Empty else body: prefer omitting it entirely to avoid accidentally
       attaching subsequent standalone 'if' statements as else-if arms. */
    bool else_body_empty = true;
    {
        bool saw_stmt = false;
        for (size_t j = i + 2; j < program->count && j < i + 512; j++) {
            const IRInst *mj = &program->insts[j];
            if (mj->op == OP_SET_LABEL && mj->has_arg1 && mj->arg1 == ctx->end_label) break;
            if (mj->op == OP_BEGIN_FUNCT || mj->op == OP_DEFINE_FUNCT) break;
            if (mj->op == OP_OP && mj->has_arg1 && (mj->arg1 == 0 || mj->arg1 == 16 || mj->arg1 == 20 || mj->arg1 == 48) && mj->has_arg2) {
                saw_stmt = true;
                break;
            }
        }
        else_body_empty = !saw_stmt;
    }
    if (else_body_empty) {
        int indent_col0 = ctx->depth * 4;
        if (ctx->brace_style) {
            if (!ael_emit_at(out, out->line0, indent_col0)) return IR2AEL_STATUS_FAIL_EMIT;
            if (!ael_emit_text(out, "}\n")) return IR2AEL_STATUS_FAIL_EMIT;
            anon_depth_pop_expected(&st->anon_depth_sp, st->anon_depth_stack, ctx->depth + 1, true);
        }
        if (!ael_emit_at(out, out->line0, indent_col0)) return IR2AEL_STATUS_FAIL_EMIT;
        if (!ael_emit_text(out, "else;\n")) return IR2AEL_STATUS_FAIL_EMIT;
        st->if_sp--;
        *idx = i + 1; /* consume SET_LABEL else_label */
        return IR2AEL_STATUS_HANDLED;
    }

    if (!ctx->brace_style) {
        /* Non-braced else: let the subsequent SET_LABEL handler emit "else" (and possible
           no-brace formatting); only the else-if case is handled above. */
        return IR2AEL_STATUS_HANDLED;
    }

    bool else_has_block = else_body_has_brace_block(program, i + 2, ctx->end_label, ctx->depth);
    /* When scope-block reconstruction is disabled, prefer braced else bodies for stability. */
    if (!else_has_block && !out->allow_num_local_scope_blocks) {
        else_has_block = true;
    }

    /* Emit else in stream order (avoid backward positioning). */
    int indent_col0 = ctx->depth * 4;
    if (!ael_emit_at(out, out->line0, indent_col0)) return IR2AEL_STATUS_FAIL_EMIT;
    if (!ael_emit_text(out, "}\n")) return IR2AEL_STATUS_FAIL_EMIT;
    anon_depth_pop_expected(&st->anon_depth_sp, st->anon_depth_stack, ctx->depth + 1, true);

    if (!ael_emit_at(out, out->line0, indent_col0)) return IR2AEL_STATUS_FAIL_EMIT;
    if (!else_has_block) {
        if (!ael_emit_text(out, "else\n")) return IR2AEL_STATUS_FAIL_EMIT;
        ctx->else_brace_style = false;
        ctx->stage = 2;
        *idx = i + 1; /* consume SET_LABEL else_label */
        return IR2AEL_STATUS_HANDLED;
    }

    if (!(st->in_function || st->pending_defun)) {
        if (!ael_emit_text(out, "else\n")) return IR2AEL_STATUS_FAIL_EMIT;
        if (!ael_emit_at(out, out->line0 + 1, indent_col0)) return IR2AEL_STATUS_FAIL_EMIT;
        if (!ael_emit_text(out, "{\n")) return IR2AEL_STATUS_FAIL_EMIT;
    } else {
        if (!ael_emit_text(out, "else {\n")) return IR2AEL_STATUS_FAIL_EMIT;
    }
    (void)anon_depth_push_marked(&st->anon_depth_sp, st->anon_depth_stack, ctx->depth + 1, true);
    ctx->else_brace_style = true;
    ctx->stage = 2;
    *idx = i + 1; /* consume SET_LABEL else_label */
    return IR2AEL_STATUS_HANDLED;
}

static Ir2AelStatus handle_branch_true_break_continue(Ir2AelState *st, size_t i, const IRInst *inst) {
    if (!st || !inst) return IR2AEL_STATUS_FAIL;
    const IRProgram *program = st->program;
    AelEmitter *out = st->out;

    if (i < 2) return IR2AEL_STATUS_NOT_HANDLED;

    size_t op_idx = i - 1;
    if (program->insts[op_idx].op == OP_ADD_LABEL && op_idx > 0) op_idx--;
    if (!(op_idx >= 1 &&
          program->insts[op_idx - 1].op == OP_LOAD_TRUE &&
          (program->insts[op_idx].op == OP_LOOP_EXIT || program->insts[op_idx].op == OP_LOOP_AGAIN))) {
        return IR2AEL_STATUS_NOT_HANDLED;
    }

    bool is_continue = (program->insts[op_idx].op == OP_LOOP_AGAIN);
    int stmt_line0 = inst->has_arg2 ? inst->arg2 : out->line0;
    int stmt_col0 = inst->has_arg3 ? inst->arg3 : decl_indent_col0_from_depth(st->cur_depth);

    /* Consume the LOAD_TRUE pseudo-expression so it never turns into a stray "TRUE;" statement. */
    stack_clear(st->stack, &st->stack_len);

    if (st->sw.active && !is_continue) {
        if (!st->sw.has_end_label) {
            st->sw.end_label = inst->has_arg1 ? inst->arg1 : -1;
            st->sw.has_end_label = true;
        }
        if (inst->has_arg1 && inst->arg1 == st->sw.end_label) {
            /* Filter out internal switch loop branches that reuse LOOP_EXIT+BRANCH_TRUE. */
            if (switch_is_epilogue_branch(program, i, &st->sw)) {
                return IR2AEL_STATUS_HANDLED;
            }
            if (!switch_emit_pending_case_before_stmt(out, &st->sw, stmt_line0, stmt_col0, &st->anon_depth_sp, st->anon_depth_stack)) return IR2AEL_STATUS_FAIL_EMIT;
            if (!stmt_emit_at_or_current(out, &stmt_line0, &stmt_col0, st->cur_depth)) return IR2AEL_STATUS_FAIL_EMIT;
            if (!ael_emit_text(out, "break;\n")) return IR2AEL_STATUS_FAIL_EMIT;
            st->sw.last_break_line0 = stmt_line0;
            return IR2AEL_STATUS_HANDLED;
        }
    }

    if (st->for_hdr_sp > 0 && st->loop_sp > 0 &&
        st->loop_stack[st->loop_sp - 1].kind == 3 &&
        inst->has_arg2 && inst->arg2 == st->for_hdr_stack[st->for_hdr_sp - 1].line0) {
        return IR2AEL_STATUS_HANDLED;
    }

    if (st->loop_sp > 0 && inst->has_arg1) {
        LoopCtx *lctx = &st->loop_stack[st->loop_sp - 1];
        if (!is_continue && lctx->kind == 3) {
            /* For-loop header scaffolds can contain a LOOP_EXIT+BRANCH_TRUE that is not a real break. */
            size_t next = ir_skip_locals_bookkeeping(program, i + 1);
            if (next < program->count && program->insts[next].op == OP_ADD_LABEL) {
                next = ir_skip_locals_bookkeeping(program, next + 1);
            }
            if (next < program->count && program->insts[next].op == OP_LOOP_AGAIN) {
                return IR2AEL_STATUS_HANDLED;
            }
        }
        if (!is_continue) {
            /* If we have not yet identified the loop end label, infer it from the break branch. */
            if (lctx->end_label < 0) lctx->end_label = inst->arg1;
            if (inst->arg1 == lctx->end_label) {
                if (!stmt_emit_at_or_current(out, &stmt_line0, &stmt_col0, st->cur_depth)) return IR2AEL_STATUS_FAIL_EMIT;
                if (!ael_emit_text(out, "break;\n")) return IR2AEL_STATUS_FAIL_EMIT;
                return IR2AEL_STATUS_HANDLED;
            }
        } else {
            if (lctx->continue_label < 0) lctx->continue_label = inst->arg1;
            if (inst->arg1 == lctx->continue_label) {
                /* Skip the implicit loop-back branch at the loop header position. */
                if (stmt_line0 == lctx->header_line0 && stmt_col0 == lctx->header_col0) {
                    return IR2AEL_STATUS_HANDLED;
                }
                if (!stmt_emit_at_or_current(out, &stmt_line0, &stmt_col0, st->cur_depth)) return IR2AEL_STATUS_FAIL_EMIT;
                if (!ael_emit_text(out, "continue;\n")) return IR2AEL_STATUS_FAIL_EMIT;
                return IR2AEL_STATUS_HANDLED;
            }
        }
    }

    return IR2AEL_STATUS_NOT_HANDLED;
}

static Ir2AelStatus handle_branch_true_for_header_cond_terminator(Ir2AelState *st, size_t i, const IRInst *inst) {
    if (!st || !inst) return IR2AEL_STATUS_FAIL;
    AelEmitter *out = st->out;
    char *err = st->err;
    size_t err_cap = st->err_cap;

    if (!(st->for_hdr_sp > 0 && st->for_hdr_stack[st->for_hdr_sp - 1].stage == 1 &&
          inst->has_arg2 && inst->has_arg3 &&
          inst->arg2 == st->for_hdr_stack[st->for_hdr_sp - 1].line0)) {
        return IR2AEL_STATUS_NOT_HANDLED;
    }

    ForHeaderCtx *fh = &st->for_hdr_stack[st->for_hdr_sp - 1];
    Expr *cond = stack_pop(st->stack, &st->stack_len);
    stack_clear(st->stack, &st->stack_len);
    if (!cond) {
        if (err && err_cap) snprintf(err, err_cap, "for without condition at IR index %zu", i);
        return IR2AEL_STATUS_FAIL;
    }
    if (!ael_emit_at(out, fh->line0, fh->cond_start_col0)) {
        expr_free(cond);
        return IR2AEL_STATUS_FAIL_EMIT;
    }
    if (!emit_expr_addr(out, cond, 0)) {
        expr_free(cond);
        return IR2AEL_STATUS_FAIL_EMIT;
    }
    expr_free(cond);
    if (!ael_emit_at(out, fh->line0, inst->arg3)) return IR2AEL_STATUS_FAIL_EMIT;
    if (!ael_emit_text(out, "; ")) return IR2AEL_STATUS_FAIL_EMIT;
    fh->stage = 2;
    return IR2AEL_STATUS_HANDLED;
}

static Ir2AelStatus handle_branch_true_while_header_negated(Ir2AelState *st, size_t i, const IRInst *inst) {
    if (!st || !inst) return IR2AEL_STATUS_FAIL;
    const IRProgram *program = st->program;
    char *err = st->err;
    size_t err_cap = st->err_cap;

    if (!(i >= 2 && st->stack_len > 0 &&
          st->stack[st->stack_len - 1] && st->stack[st->stack_len - 1]->kind == EXPR_UNOP &&
          st->stack[st->stack_len - 1]->op_code == 3 &&
          program->insts[i - 1].op == OP_ADD_LABEL &&
          program->insts[i - 2].op == OP_LOOP_EXIT)) {
        return IR2AEL_STATUS_NOT_HANDLED;
    }

    Expr *cond_neg = stack_pop(st->stack, &st->stack_len);
    stack_clear(st->stack, &st->stack_len);
    if (!cond_neg) {
        if (err && err_cap) snprintf(err, err_cap, "while without condition at IR index %zu", i);
        return IR2AEL_STATUS_FAIL;
    }
    Expr *cond = cond_neg;
    if (cond_neg->kind == EXPR_UNOP && cond_neg->op_code == 3 && cond_neg->rhs) {
        cond = cond_neg->rhs;
        cond_neg->rhs = NULL;
        expr_free(cond_neg);
    }

    int line0 = inst->has_arg2 ? inst->arg2 : 0;
    int lparen_col0 = inst->has_arg3 ? inst->arg3 : 0;
    Ir2AelStatus emit_status = emit_while_header_common(st, line0, lparen_col0, cond, false, NULL);
    expr_free(cond);
    if (emit_status != IR2AEL_STATUS_HANDLED) return emit_status;

    if (st->loop_sp < (int)(sizeof(st->loop_stack) / sizeof(st->loop_stack[0]))) {
        st->loop_stack[st->loop_sp].kind = 1; /* while */
        st->loop_stack[st->loop_sp].depth = st->cur_depth;
        st->loop_stack[st->loop_sp].start_label = -1;
        st->loop_stack[st->loop_sp].continue_label = -1;
        st->loop_stack[st->loop_sp].header_line0 = line0;
        st->loop_stack[st->loop_sp].header_col0 = lparen_col0;
        for (int bk = 1; bk <= 16 && (int)i - bk >= 0; bk++) {
            const IRInst *prev = &program->insts[i - (size_t)bk];
            if (prev->op == OP_SET_LABEL && prev->has_arg1) {
                st->loop_stack[st->loop_sp].start_label = prev->arg1;
                break;
            }
        }
        st->loop_stack[st->loop_sp].continue_label = st->loop_stack[st->loop_sp].start_label;
        st->loop_stack[st->loop_sp].end_label = inst->arg1;
        st->loop_stack[st->loop_sp].header_emitted = true;
        st->loop_sp++;
    }
    (void)anon_depth_push_marked(&st->anon_depth_sp, st->anon_depth_stack, st->cur_depth + 1, true);
    return IR2AEL_STATUS_HANDLED;
}

static Ir2AelStatus handle_branch_true_do_while_footer(Ir2AelState *st, size_t i, const IRInst *inst) {
    if (!st || !inst) return IR2AEL_STATUS_FAIL;
    AelEmitter *out = st->out;
    char *err = st->err;
    size_t err_cap = st->err_cap;

    if (!(st->loop_sp > 0 && st->loop_stack[st->loop_sp - 1].kind == 2 && inst->has_arg1 &&
          inst->arg1 == st->loop_stack[st->loop_sp - 1].start_label && inst->has_arg2)) {
        return IR2AEL_STATUS_NOT_HANDLED;
    }

    Expr *cond = stack_pop(st->stack, &st->stack_len);
    stack_clear(st->stack, &st->stack_len);
    if (!cond) {
        cond = expr_new(EXPR_BOOL);
        if (!cond) return IR2AEL_STATUS_OOM;
        cond->bool_value = 1;
        cond->op_line0 = inst->has_arg2 ? inst->arg2 : -1;
        cond->op_col0 = inst->has_arg3 ? inst->arg3 : -1;
    }
    int while_line0 = inst->arg2;
    int while_col0 = inst->has_arg3 ? inst->arg3 : 0;
    if (while_col0 == 0) {
        /* Multiline style: '}' on previous line, then 'while (cond);' on its own line. */
        if (!ael_emit_at(out, while_line0 - 1, 0)) {
            expr_free(cond);
            return IR2AEL_STATUS_FAIL_EMIT;
        }
        if (!ael_emit_text(out, "}\n")) {
            expr_free(cond);
            return IR2AEL_STATUS_FAIL_EMIT;
        }
        if (!ael_emit_at(out, while_line0, 0)) {
            expr_free(cond);
            return IR2AEL_STATUS_FAIL_EMIT;
        }
        if (!ael_emit_text(out, "while (")) {
            expr_free(cond);
            return IR2AEL_STATUS_FAIL_EMIT;
        }
    } else {
        /* Inline style: "} while (cond);" */
        int rbrace_col0 = while_col0 - 2; /* "} " before "while" */
        if (rbrace_col0 < 0) rbrace_col0 = 0;
        if (!ael_emit_at(out, while_line0, rbrace_col0)) {
            expr_free(cond);
            return IR2AEL_STATUS_FAIL_EMIT;
        }
        if (!ael_emit_text(out, "} while (")) {
            expr_free(cond);
            return IR2AEL_STATUS_FAIL_EMIT;
        }
    }
    if (!emit_expr_addr(out, cond, 0)) {
        expr_free(cond);
        return IR2AEL_STATUS_FAIL_EMIT;
    }
    expr_free(cond);
    if (!ael_emit_text(out, ");\n")) return IR2AEL_STATUS_FAIL_EMIT;

    {
        LoopCtx *lctx = &st->loop_stack[st->loop_sp - 1];
        anon_depth_pop_expected(&st->anon_depth_sp, st->anon_depth_stack, lctx->depth + 1, true);
    }
    st->loop_sp--;
    return IR2AEL_STATUS_HANDLED;
}

Ir2AelStatus ir2ael_flow_handle_branch_true(Ir2AelState *s, size_t *idx, const IRInst *inst) {
    if (!s || !inst || !idx) return IR2AEL_STATUS_FAIL;
    Ir2AelState *st = s;
    size_t i = *idx;

    if (inst->op != OP_BRANCH_TRUE) {
        *idx = i;
        return IR2AEL_STATUS_NOT_HANDLED;
    }

    Ir2AelStatus status = handle_branch_true_while_header_terminator(st, i, inst);
    if (status != IR2AEL_STATUS_NOT_HANDLED) {
        *idx = i;
        return status;
    }

    status = handle_branch_true_for_header_empty_init(st, i, inst);
    if (status != IR2AEL_STATUS_NOT_HANDLED) {
        *idx = i;
        return status;
    }

    status = handle_branch_true_braced_else_transition(st, &i, inst);
    if (status != IR2AEL_STATUS_NOT_HANDLED) {
        *idx = i;
        return status;
    }

    status = handle_branch_true_break_continue(st, i, inst);
    if (status == IR2AEL_STATUS_HANDLED || status == IR2AEL_STATUS_FAIL || status == IR2AEL_STATUS_FAIL_EMIT || status == IR2AEL_STATUS_OOM) {
        *idx = i;
        return status;
    }

    status = handle_branch_true_for_header_cond_terminator(st, i, inst);
    if (status != IR2AEL_STATUS_NOT_HANDLED) {
        *idx = i;
        return status;
    }

    status = handle_branch_true_while_header_negated(st, i, inst);
    if (status != IR2AEL_STATUS_NOT_HANDLED) {
        *idx = i;
        return status;
    }

    status = handle_branch_true_do_while_footer(st, i, inst);
    if (status != IR2AEL_STATUS_NOT_HANDLED) {
        *idx = i;
        return status;
    }

    *idx = i;
    return IR2AEL_STATUS_HANDLED;
}
