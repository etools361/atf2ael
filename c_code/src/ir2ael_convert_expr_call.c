/* autogenerated: expr handler */
#include "ir2ael_internal.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

Ir2AelStatus ir2ael_expr_handle_list_call_ops(Ir2AelState *s, size_t *idx, const IRInst *inst) {
    if (!s || !inst || !idx) return IR2AEL_STATUS_FAIL;
    if (inst->op != OP_OP) return IR2AEL_STATUS_NOT_HANDLED;
    Ir2AelState *st = s;
    const IRProgram *program = s->program;
    AelEmitter *out = s->out;
    char *err = s->err;
    size_t err_cap = s->err_cap;
    size_t i = *idx;
    int op_code = inst->has_arg1 ? inst->arg1 : 0;
    if (!(op_code == 53 || op_code == 59 || op_code == 60 || op_code == 61 || op_code == 65 || op_code == 46 || op_code == 56 || op_code == 48)) return IR2AEL_STATUS_NOT_HANDLED;

#define RETURN_STATUS(_status) do { *idx = i; return (_status); } while (0)

    do {
            if (op_code == 53) {
                /* LIST marker */
                continue;
            }
            if (op_code == 59 || op_code == 60 || op_code == 61 || op_code == 65) {
                /* IF/ternary template markers: templates are recognized elsewhere; ignore here so
                   atf2ael doesn't fail hard when the marker appears outside our template windows. */
                continue;
            }
            if (op_code == 46) {
                /* BUILD_LIST: pop N items, build list, push back */
                int n = inst->has_a4 ? inst->a4 : 0;
                if (n < 0) n = 0;
                Expr **items = NULL;
                if (n > 0) {
                    items = (Expr **)calloc((size_t)n, sizeof(Expr *));
                    if (!items) goto oom;
                    for (int k = n - 1; k >= 0; k--) {
                        items[k] = stack_pop(st->stack, &st->stack_len);
                        if (!items[k]) {
                            for (int t = k; t < n; t++) expr_free(items[t]);
                            free(items);
                            if (err && err_cap) snprintf(err, err_cap, "bad list st->stack at IR index %zu", i);
                            goto fail;
                        }
                    }
                }
                Expr *e = expr_new(EXPR_LIST);
                if (!e) {
                    for (int k = 0; k < n; k++) expr_free(items[k]);
                    free(items);
                    goto oom;
                }
                e->items = items;
                e->item_count = n;
                e->close_line0 = inst->has_arg2 ? inst->arg2 : -1;
                e->close_col0 = inst->has_arg3 ? inst->arg3 : -1;
                if (!stack_push(&st->stack, &st->stack_len, &st->stack_cap, e)) {
                    expr_free(e);
                    goto oom;
                }
                continue;
            }

            if (op_code == 56) {
                /* PUSH_ARGS: record '(' position and argument count for CALL */
                Expr *m = expr_new(EXPR_CALLARGS);
                if (!m) goto oom;
                m->call_argc = inst->has_a4 ? inst->a4 : 0;
                if (m->call_argc < 0) m->call_argc = 0;
                m->lparen_line0 = inst->has_arg2 ? inst->arg2 : -1;
                m->lparen_col0 = inst->has_arg3 ? inst->arg3 : -1;
                if (!stack_push(&st->stack, &st->stack_len, &st->stack_cap, m)) {
                    expr_free(m);
                    goto oom;
                }
                continue;
            }

            if (op_code == 48) {
                /* CALL or indexing: disambiguate by preceding PUSH_ARGS marker */
                if (st->stack_len > 0 && st->stack[st->stack_len - 1] && st->stack[st->stack_len - 1]->kind == EXPR_CALLARGS) {
                    Expr *m = stack_pop(st->stack, &st->stack_len);
                    int argc = m ? m->call_argc : 0;
                    if (argc < 0) argc = 0;

                    Expr **args = NULL;
                    if (argc > 0) {
                        args = (Expr **)calloc((size_t)argc, sizeof(Expr *));
                        if (!args) {
                            expr_free(m);
                            goto oom;
                        }
                        for (int k = argc - 1; k >= 0; k--) {
                            args[k] = stack_pop(st->stack, &st->stack_len);
                            if (!args[k]) {
                                for (int t = k; t < argc; t++) expr_free(args[t]);
                                free(args);
                                expr_free(m);
                                if (err && err_cap) snprintf(err, err_cap, "bad call args st->stack at IR index %zu", i);
                                goto fail;
                            }
                        }
                    }

                    Expr *callee = stack_pop(st->stack, &st->stack_len);
                    if (!callee) {
                        for (int t = 0; t < argc; t++) expr_free(args ? args[t] : NULL);
                        free(args);
                        expr_free(m);
                        if (err && err_cap) snprintf(err, err_cap, "bad call callee st->stack at IR index %zu", i);
                        goto fail;
                    }

                    Expr *ce = expr_new(EXPR_CALL);
                    if (!ce) {
                        expr_free(callee);
                        for (int t = 0; t < argc; t++) expr_free(args ? args[t] : NULL);
                        free(args);
                        expr_free(m);
                        goto oom;
                    }
                    ce->lhs = callee;
                    ce->call_args = args;
                    ce->call_arg_count = argc;
                    ce->lparen_line0 = m ? m->lparen_line0 : -1;
                    ce->lparen_col0 = m ? m->lparen_col0 : -1;
                    ce->op_line0 = inst->has_arg2 ? inst->arg2 : -1;
                    ce->op_col0 = inst->has_arg3 ? inst->arg3 : -1;
                    expr_free(m);

                    if (!stack_push(&st->stack, &st->stack_len, &st->stack_cap, ce)) {
                        expr_free(ce);
                        goto oom;
                    }
                    continue;
                }

                /* Indexing chain: baseline IR for chained brackets pushes all indices first,
                 * then emits consecutive OP=48 (INDEX) ops. Reconstruct as nested indexing.
                 */
                int group_counts[32];
                int group_line0[32];
                int group_col0[32];
                int group_n = 0;
                int total_index_items = 0;
                size_t run_end = i;
                for (size_t j = i; j < program->count && group_n < (int)(sizeof(group_counts) / sizeof(group_counts[0])); j++) {
                    const IRInst *mj = &program->insts[j];
                    if (mj->op != OP_OP || !mj->has_arg1 || mj->arg1 != 48) break;
                    int a4j = mj->has_a4 ? mj->a4 : 0;
                    int ic = a4j - 1;
                    if (ic <= 0) break;
                    group_counts[group_n] = ic;
                    group_line0[group_n] = mj->has_arg2 ? mj->arg2 : -1;
                    group_col0[group_n] = mj->has_arg3 ? mj->arg3 : -1;
                    group_n++;
                    total_index_items += ic;
                    run_end = j + 1;
                }

                if (group_n <= 0 || total_index_items <= 0) {
                    int a4 = inst->has_a4 ? inst->a4 : 0;
                    if (err && err_cap) snprintf(err, err_cap, "bad index arity a4=%d at IR index %zu", a4, i);
                    goto fail;
                }

                Expr **all_idxs = (Expr **)calloc((size_t)total_index_items, sizeof(Expr *));
                if (!all_idxs) goto oom;
                for (int k = total_index_items - 1; k >= 0; k--) {
                    all_idxs[k] = stack_pop(st->stack, &st->stack_len);
                    if (!all_idxs[k]) {
                        for (int t = k; t < total_index_items; t++) expr_free(all_idxs[t]);
                        free(all_idxs);
                        if (err && err_cap) snprintf(err, err_cap, "bad index st->stack at IR index %zu", i);
                        goto fail;
                    }
                }
                Expr *base = stack_pop(st->stack, &st->stack_len);
                if (!base) {
                    for (int t = 0; t < total_index_items; t++) expr_free(all_idxs[t]);
                    free(all_idxs);
                    if (err && err_cap) snprintf(err, err_cap, "bad index base st->stack at IR index %zu", i);
                    goto fail;
                }

                Expr *cur = base;
                int off = 0;
                for (int g = 0; g < group_n; g++) {
                    int ic = group_counts[g];
                    Expr **idxs = (Expr **)calloc((size_t)ic, sizeof(Expr *));
                    if (!idxs) {
                        expr_free(cur);
                        for (int t = off; t < total_index_items; t++) expr_free(all_idxs[t]);
                        free(all_idxs);
                        goto oom;
                    }
                    for (int t = 0; t < ic; t++) {
                        idxs[t] = all_idxs[off + t];
                        all_idxs[off + t] = NULL;
                    }
                    Expr *ie = expr_new(EXPR_INDEX);
                    if (!ie) {
                        expr_free(cur);
                        for (int t = 0; t < ic; t++) expr_free(idxs[t]);
                        free(idxs);
                        for (int t = off + ic; t < total_index_items; t++) expr_free(all_idxs[t]);
                        free(all_idxs);
                        goto oom;
                    }
                    ie->index_base = cur;
                    ie->index_items = idxs;
                    ie->index_count = ic;
                    ie->op_line0 = group_line0[g];
                    ie->op_col0 = group_col0[g];
                    cur = ie;
                    off += ic;
                }
                free(all_idxs);

                if (!stack_push(&st->stack, &st->stack_len, &st->stack_cap, cur)) {
                    expr_free(cur);
                    goto oom;
                }
                i = run_end - 1;
                continue;
            }

    } while (0);
    RETURN_STATUS(IR2AEL_STATUS_HANDLED);
oom:
    RETURN_STATUS(IR2AEL_STATUS_OOM);
fail:
    RETURN_STATUS(IR2AEL_STATUS_FAIL);
#undef RETURN_STATUS
}
