/* autogenerated: expr handler */
#include "ir2ael_internal.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

static Expr *build_fallback_assign_call(Expr *lhs, Expr *rhs, const IRInst *inst) {
    if (!lhs || !rhs || !inst) return NULL;
    Expr **args = (Expr **)calloc(2, sizeof(Expr *));
    if (!args) return NULL;
    args[0] = lhs;
    args[1] = rhs;
    Expr *callee = expr_new(EXPR_VAR);
    if (!callee) {
        free(args);
        return NULL;
    }
    callee->text = _strdup("__assign");
    if (!callee->text) {
        expr_free(callee);
        free(args);
        return NULL;
    }
    Expr *ce = expr_new(EXPR_CALL);
    if (!ce) {
        expr_free(callee);
        free(args);
        return NULL;
    }
    ce->lhs = callee;
    ce->call_args = args;
    ce->call_arg_count = 2;
    ce->op_line0 = inst->has_arg2 ? inst->arg2 : -1;
    ce->op_col0 = inst->has_arg3 ? inst->arg3 : -1;
    return ce;
}

static bool emit_do_while_header_if_needed(Ir2AelState *st, int stmt_line0, int stmt_col0, int inline_col_offset) {
    if (!st) return false;
    if (st->loop_sp <= 0) return true;
    LoopCtx *lctx = &st->loop_stack[st->loop_sp - 1];
    if (lctx->kind != 2 || lctx->header_emitted) return true;
    AelEmitter *out = st->out;
    if (!out) return false;

    if (lctx->while_col0 == 0) {
        int do_line0 = stmt_line0 - 2;
        if (do_line0 < 0) do_line0 = 0;
        if (!ael_emit_at(out, do_line0, 0)) return false;
        if (!ael_emit_text(out, "do\n")) return false;
        if (!ael_emit_at(out, do_line0 + 1, 0)) return false;
        if (!ael_emit_text(out, "{\n")) return false;
    } else {
        int do_line0 = stmt_line0 - 1;
        int do_col0 = stmt_col0 + inline_col_offset;
        if (do_line0 < 0) do_line0 = 0;
        if (do_col0 < 0) do_col0 = 0;
        if (!ael_emit_at(out, do_line0, do_col0)) return false;
        if (!ael_emit_text(out, "do {\n")) return false;
    }

    lctx->header_emitted = true;
    return true;
}

static bool emit_stmt_end_from_ir(const IRProgram *program, size_t *i, AelEmitter *out, int guard_line0, bool guard_on_out_line) {
    if (!program || !i || !out) return false;
    const IRInst *next = (*i + 1 < program->count) ? &program->insts[*i + 1] : NULL;
    if (next && next->op == OP_OP && next->has_arg1 && next->arg1 == 0 && next->has_arg2 && next->has_arg3) {
        bool can_seek = false;
        if (guard_on_out_line) {
            can_seek = (next->arg2 > out->line0 || (next->arg2 == out->line0 && next->arg3 >= out->col0));
        } else {
            can_seek = (next->arg2 > guard_line0 || next->arg3 >= out->col0);
        }
        if (can_seek) {
            if (!ael_emit_at(out, next->arg2, next->arg3)) return false;
        }
        bool inline_break = looks_like_inline_break_after_stmt_end(program, *i + 1, next->arg2);
        if (!ael_emit_text(out, inline_break ? "; " : ";\n")) return false;
        (*i)++;
        return true;
    }
    return ael_emit_text(out, ";\n");
}

static Ir2AelStatus try_emit_for_header_init(Ir2AelState *st, const IRInst *inst, size_t i, Expr *lhs, Expr *rhs) {
    if (!st || !inst) return IR2AEL_STATUS_FAIL;
    if (!lhs || !rhs) return IR2AEL_STATUS_FAIL;
    if (lhs->kind != EXPR_VAR || st->for_hdr_sp != 0 || !inst->has_arg2 || !inst->has_arg3) return IR2AEL_STATUS_NOT_HANDLED;
    if (!lhs->text) {
        if (st->err && st->err_cap) snprintf(st->err, st->err_cap, "for header init missing lhs at IR index %zu", i);
        return IR2AEL_STATUS_FAIL;
    }

    const IRProgram *program = st->program;
    AelEmitter *out = st->out;
    size_t idx_add_label = ir_skip_locals_bookkeeping(program, i + 1);
    size_t idx_begin_loop =
        (idx_add_label < program->count && program->insts[idx_add_label].op == OP_ADD_LABEL)
            ? ir_skip_locals_bookkeeping(program, idx_add_label + 1)
            : program->count;
    size_t idx_set_label =
        (idx_begin_loop < program->count && program->insts[idx_begin_loop].op == OP_BEGIN_LOOP)
            ? ir_skip_locals_bookkeeping(program, idx_begin_loop + 1)
            : program->count;
    if (idx_set_label >= program->count ||
        program->insts[idx_set_label].op != OP_SET_LABEL || !program->insts[idx_set_label].has_arg1) {
        return IR2AEL_STATUS_NOT_HANDLED;
    }

    int line0 = inst->arg2;
    int id_col0 = inst->arg3;
    int lparen_col0 = id_col0 - 1;
    if (lparen_col0 < 0) lparen_col0 = 0;
    int for_col0 = lparen_col0 - 4; /* strlen("for ") */
    if (for_col0 < 0) for_col0 = 0;
    int cond_col0 = -1;
    if (!find_for_header_cond_col0(program, i + 1, 80, line0, &cond_col0)) {
        cond_col0 = id_col0 + 6;
    }
    int semi1_col0 = cond_col0 - 2;
    if (semi1_col0 < 0) semi1_col0 = 0;

    /* Ensure locals declared right before the loop header stay in scope. */
    bool same_name_decl = (st->pending_decls.count == 1 && lhs->kind == EXPR_VAR && lhs->text &&
                           strcmp(st->pending_decls.names[0], lhs->text) == 0);
    if (st->pending_decls.count > 0 && st->pending_decls.is_local &&
        st->pending_decls.in_function == (st->in_function || st->pending_defun) &&
        (st->pending_decls.depth == st->cur_depth || (!out->strict_pos && same_name_decl))) {
        int decl_line0 = line0 - 1;
        if (decl_line0 < out->line0) decl_line0 = out->line0;
        int decl_col0 = decl_indent_col0_from_depth(st->cur_depth > 0 ? st->cur_depth : 1);
        if (st->in_function && !anon_close_scopes_before_stmt(out, &st->anon_depth_sp, st->anon_depth_stack, st->cur_depth, decl_line0)) return IR2AEL_STATUS_FAIL_EMIT;
        if (!decl_group_emit_and_track(out, &st->pending_decls, decl_line0, decl_col0, &st->local_init)) return IR2AEL_STATUS_FAIL_EMIT;
        decl_group_clear(&st->pending_decls);
    }

    if (!ael_emit_at(out, line0, for_col0)) return IR2AEL_STATUS_FAIL_EMIT;
    if (!ael_emit_text(out, "for ")) return IR2AEL_STATUS_FAIL_EMIT;
    if (!ael_emit_at(out, line0, lparen_col0)) return IR2AEL_STATUS_FAIL_EMIT;
    if (!ael_emit_char(out, '(')) return IR2AEL_STATUS_FAIL_EMIT;

    if (!ael_emit_at(out, line0, id_col0)) return IR2AEL_STATUS_FAIL_EMIT;
    if (!ael_emit_text(out, lhs->text)) return IR2AEL_STATUS_FAIL_EMIT;
    if (!ael_emit_text(out, " = ")) return IR2AEL_STATUS_FAIL_EMIT;
    if (!emit_expr_addr(out, rhs, 0)) return IR2AEL_STATUS_FAIL_EMIT;

    if (!ael_emit_at(out, line0, semi1_col0)) return IR2AEL_STATUS_FAIL_EMIT;
    if (!ael_emit_text(out, "; ")) return IR2AEL_STATUS_FAIL_EMIT;

    if (st->for_hdr_sp < (int)(sizeof(st->for_hdr_stack) / sizeof(st->for_hdr_stack[0]))) {
        st->for_hdr_stack[st->for_hdr_sp].line0 = line0;
        st->for_hdr_stack[st->for_hdr_sp].cond_start_col0 = cond_col0;
        st->for_hdr_stack[st->for_hdr_sp].stage = 1;
        st->for_hdr_sp++;
    }
    if (st->loop_sp < (int)(sizeof(st->loop_stack) / sizeof(st->loop_stack[0]))) {
        st->loop_stack[st->loop_sp].kind = 3; /* for */
        st->loop_stack[st->loop_sp].depth = st->cur_depth;
        st->loop_stack[st->loop_sp].start_label = -1;
        st->loop_stack[st->loop_sp].continue_label = -1;
        st->loop_stack[st->loop_sp].end_label = -1;
        st->loop_stack[st->loop_sp].header_line0 = line0;
        st->loop_stack[st->loop_sp].header_col0 = lparen_col0;
        st->loop_stack[st->loop_sp].cond_rparen_col0 = -1;
        st->loop_stack[st->loop_sp].header_emitted = true;
        st->loop_stack[st->loop_sp].body_has_brace = false;
        st->loop_sp++;
    }

    return IR2AEL_STATUS_HANDLED;
}

static Ir2AelStatus try_emit_for_header_update(Ir2AelState *st, const IRInst *inst, size_t i, Expr *lhs, Expr *rhs) {
    if (!st || !inst) return IR2AEL_STATUS_FAIL;
    if (!lhs || !rhs) return IR2AEL_STATUS_FAIL;
    if (lhs->kind != EXPR_VAR || st->for_hdr_sp <= 0 || !inst->has_arg2) return IR2AEL_STATUS_NOT_HANDLED;
    if (!lhs->text) {
        if (st->err && st->err_cap) snprintf(st->err, st->err_cap, "for header update missing lhs");
        return IR2AEL_STATUS_FAIL;
    }

    ForHeaderCtx *fh = &st->for_hdr_stack[st->for_hdr_sp - 1];
    if (fh->stage != 2 || inst->arg2 != fh->line0) return IR2AEL_STATUS_NOT_HANDLED;
    if (for_header_has_comma_op(st->program, i, fh->line0)) return IR2AEL_STATUS_NOT_HANDLED;

    int line0 = inst->arg2;
    int id_col0 = inst->has_arg3 ? inst->arg3 : 0;
    AelEmitter *out = st->out;
    if (!ael_emit_at(out, line0, id_col0)) return IR2AEL_STATUS_FAIL_EMIT;
    if (!ael_emit_text(out, lhs->text)) return IR2AEL_STATUS_FAIL_EMIT;
    if (!ael_emit_text(out, " = ")) return IR2AEL_STATUS_FAIL_EMIT;
    if (!emit_expr_addr(out, rhs, 0)) return IR2AEL_STATUS_FAIL_EMIT;
    fh->stage = 3;
    return IR2AEL_STATUS_HANDLED;
}

Ir2AelStatus ir2ael_expr_handle_assign_ops(Ir2AelState *s, size_t *idx, const IRInst *inst) {
    if (!s || !inst || !idx) return IR2AEL_STATUS_FAIL;
    if (inst->op != OP_OP) return IR2AEL_STATUS_NOT_HANDLED;
    Ir2AelState *st = s;
    const IRProgram *program = s->program;
    AelEmitter *out = s->out;
    char *err = s->err;
    size_t err_cap = s->err_cap;
    size_t i = *idx;
    int op_code = inst->has_arg1 ? inst->arg1 : 0;
    if (!(op_code == 17 || op_code == 16)) return IR2AEL_STATUS_NOT_HANDLED;

#define RETURN_STATUS(_status) do { *idx = i; return (_status); } while (0)

    do {
            if (op_code == 17) {
                /* EXPR marker: attaches a source position to the preceding expr (most commonly identifiers). */
                if (st->stack_len > 0) {
                    Expr *top = st->stack[st->stack_len - 1];
                    if (top && top->kind != EXPR_CALLARGS) {
                        top->op_line0 = inst->has_arg2 ? inst->arg2 : -1;
                        top->op_col0 = inst->has_arg3 ? inst->arg3 : -1;
                    }
                }
                continue;
            }

            if (op_code == 16) {
                /* ASSIGN: pop rhs, lhs */
                Expr *rhs = stack_pop(st->stack, &st->stack_len);
                Expr *lhs = stack_pop(st->stack, &st->stack_len);
                if (!rhs || !lhs) {
                    expr_free(rhs);
                    expr_free(lhs);
                    if (err && err_cap) snprintf(err, err_cap, "bad assign st->stack at IR index %zu", i);
                    goto fail;
                }
                if (lhs->kind != EXPR_VAR && lhs->kind != EXPR_INDEX) {
                    Expr *fallback = build_fallback_assign_call(lhs, rhs, inst);
                    if (!fallback) {
                        expr_free(rhs);
                        expr_free(lhs);
                        goto oom;
                    }
                    if (!stack_push(&st->stack, &st->stack_len, &st->stack_cap, fallback)) {
                        expr_free(fallback);
                        goto oom;
                    }
                    continue;
                }
                if (lhs->kind == EXPR_VAR && lhs->text) {
                    local_init_mark_assigned(&st->local_init, lhs->text);
                }

                /* Assignment used as an expression (no trailing STMT_END): push "lhs = rhs" back onto the st->stack. */
                bool next_is_stmt_end = false;
                if (i + 1 < program->count) {
                    const IRInst *n1 = &program->insts[i + 1];
                    if (n1->op == OP_OP && n1->has_arg1 && n1->arg1 == 0) next_is_stmt_end = true;
                }
                if (!next_is_stmt_end) {
                    Ir2AelStatus hdr_status = try_emit_for_header_init(st, inst, i, lhs, rhs);
                    if (hdr_status == IR2AEL_STATUS_HANDLED) {
                        expr_free(rhs);
                        expr_free(lhs);
                        stack_clear(st->stack, &st->stack_len);
                        decl_group_clear(&st->pending_decls);
                        continue;
                    }
                    if (hdr_status == IR2AEL_STATUS_FAIL_EMIT) goto fail_emit_assign;
                    if (hdr_status == IR2AEL_STATUS_FAIL) goto fail;

                    hdr_status = try_emit_for_header_update(st, inst, i, lhs, rhs);
                    if (hdr_status == IR2AEL_STATUS_HANDLED) {
                        expr_free(rhs);
                        expr_free(lhs);
                        stack_clear(st->stack, &st->stack_len);
                        decl_group_clear(&st->pending_decls);
                        continue;
                    }
                    if (hdr_status == IR2AEL_STATUS_FAIL_EMIT) goto fail_emit_assign;
                    if (hdr_status == IR2AEL_STATUS_FAIL) goto fail;

                    Expr *e = expr_new(EXPR_BINOP);
                    if (!e) {
                        expr_free(rhs);
                        expr_free(lhs);
                        goto oom;
                    }
                    e->op_code = 16;

                    /* '=' position isn't recorded directly in IR (arg2/arg3 often points to the identifier).
                     * Derive it from the LHS identifier when possible to match baseline spacing.
                     */
                    int line0 = lhs->op_line0;
                    int col0 = lhs->op_col0;
                    if (line0 < 0 && inst->has_arg2) line0 = inst->arg2;
                    if (col0 < 0 && inst->has_arg3) col0 = inst->arg3;
                    if (lhs->kind == EXPR_VAR && lhs->text && line0 >= 0 && col0 >= 0) {
                        col0 = col0 + (int)strlen(lhs->text) + 1; /* space before '=' */
                    }
                    e->op_line0 = line0;
                    e->op_col0 = col0;
                    e->lhs = lhs;
                    e->rhs = rhs;
                    if (!stack_push(&st->stack, &st->stack_len, &st->stack_cap, e)) {
                        expr_free(e);
                        goto oom;
                    }
                    continue;
                }

                Ir2AelStatus hdr_status = try_emit_for_header_init(st, inst, i, lhs, rhs);
                if (hdr_status == IR2AEL_STATUS_HANDLED) {
                    expr_free(rhs);
                    expr_free(lhs);
                    stack_clear(st->stack, &st->stack_len);
                    decl_group_clear(&st->pending_decls);
                    continue;
                }
                if (hdr_status == IR2AEL_STATUS_FAIL_EMIT) goto fail_emit_assign;
                if (hdr_status == IR2AEL_STATUS_FAIL) goto fail;

                hdr_status = try_emit_for_header_update(st, inst, i, lhs, rhs);
                if (hdr_status == IR2AEL_STATUS_HANDLED) {
                    expr_free(rhs);
                    expr_free(lhs);
                    stack_clear(st->stack, &st->stack_len);
                    decl_group_clear(&st->pending_decls);
                    continue;
                }
                if (hdr_status == IR2AEL_STATUS_FAIL_EMIT) goto fail_emit_assign;
                if (hdr_status == IR2AEL_STATUS_FAIL) goto fail;

                int pending_decl_match = -1;
                    if (lhs->kind == EXPR_VAR && lhs->text && st->pending_decls.count > 0) {
                        for (int di = 0; di < st->pending_decls.count; di++) {
                            if (strcmp(lhs->text, st->pending_decls.names[di]) == 0) {
                                pending_decl_match = di;
                                break;
                            }
                        }
                    }

                    /* If this assignment initializes the last name of a multi-name decl group, split it so we can
                       emit "decl a, b;" followed by "decl c = ...;" (common in mmWave demos). */
                    if (pending_decl_match >= 0 && st->pending_decls.count > 1 && pending_decl_match == st->pending_decls.count - 1) {
                        DeclGroup prefix = st->pending_decls;
                        prefix.count = st->pending_decls.count - 1;

                        int eq_line0 = inst->has_arg2 ? inst->arg2 : 0;
                        int decl_line0 = eq_line0 - 2;
                        if (decl_line0 < 0) decl_line0 = 0;
                        if (decl_line0 < out->line0) decl_line0 = out->line0;
                        int decl_col0 = prefix.is_local ? decl_indent_col0_from_depth(prefix.depth > 0 ? prefix.depth : 1) : 0;

                        if (st->in_function && !anon_close_scopes_before_stmt(out, &st->anon_depth_sp, st->anon_depth_stack, st->cur_depth, decl_line0)) goto fail_emit_assign;
                        if (!decl_group_emit_and_track(out, &prefix, decl_line0, decl_col0, &st->local_init)) goto fail_emit_assign;

                        /* Keep only the last name pending so it can be emitted as a decl initializer. */
                        strncpy(st->pending_decls.names[0], st->pending_decls.names[pending_decl_match], 255);
                        st->pending_decls.names[0][255] = '\0';
                        st->pending_decls.count = 1;
                        pending_decl_match = 0;
                    }

                    bool is_decl = (pending_decl_match == 0) && (st->pending_decls.count == 1);

                    bool treat_as_decl_init = false;
                    int eq_line0 = inst->has_arg2 ? inst->arg2 : 0;
                    int eq_col0 = inst->has_arg3 ? inst->arg3 : 0;
                    int decl_col0 = st->pending_decls.is_local ? decl_indent_col0_from_depth(st->pending_decls.depth > 0 ? st->pending_decls.depth : 1) : 0;

                    if (is_decl) {
                        /* Some baselines use non-4-space indentation; infer decl indentation from '=' when possible. */
                        if (st->pending_decls.is_local) {
                            int decl_col0_guess = eq_col0 - (5 + (int)strlen(lhs->text)); /* "decl " + name */
                            if (decl_col0_guess >= 0 && decl_col0_guess <= 64) decl_col0 = decl_col0_guess;
                        }

                        /* Baselines have both styles:
                           - "decl x = expr;"  (with spaces)
                           - "decl x=expr;"    (no spaces, common in boot files) */
                        int eq_col0_min = decl_col0 + 5 + (int)strlen(lhs->text); /* "decl " + name */
                        if (!out->strict_pos) {
                            /* When we don't care about exact column anchoring, prefer emitting decl initializers
                               for newly-added locals to match the compiler's common templates. */
                            treat_as_decl_init = true;
                        } else {
                            treat_as_decl_init = (eq_col0 >= eq_col0_min);
                        }
                    }

                    bool chain_continue_candidate =
                        st->decl_init_chain.active && st->decl_init_chain.line0 == eq_line0 &&
                        st->decl_init_chain.is_local == st->pending_decls.is_local &&
                        st->decl_init_chain.in_function == st->pending_decls.in_function &&
                        st->decl_init_chain.depth == st->pending_decls.depth;
                    if (chain_continue_candidate) {
                        /* Always keep chaining even if column metadata is missing/inexact, otherwise we can end up
                           with a dangling comma like "decl a=0," followed by a separate "decl b;". */
                        treat_as_decl_init = true;
                    }

                    if (treat_as_decl_init) {
                        /* Decl-init chaining ("decl a=..., b=...;") is fragile when StrictPos=0 because we may
                           legitimately decide to emit intervening decl/stmt lines; avoid generating a dangling
                           comma that breaks parsing (e.g., "decl a=0," then "decl b;"). */
                        const bool allow_decl_init_chain = out->strict_pos;
                        bool chain_continue = allow_decl_init_chain && chain_continue_candidate;

                        if (!chain_continue) {
                            if (st->in_function && !anon_close_scopes_before_stmt(out, &st->anon_depth_sp, st->anon_depth_stack, st->cur_depth, eq_line0)) goto fail_emit_assign;
                            if (st->pending_decls.is_local && st->pending_decls.depth > 1) {
                                /* Rely on explicit control-flow braces; avoid inserting extra blocks that can
                                   break if/else association (e.g., "if (...) { { ... } else ..."). */
                            }
                            if (!switch_emit_pending_case_before_stmt(out, &st->sw, eq_line0, decl_col0, &st->anon_depth_sp, st->anon_depth_stack)) goto fail_emit_assign;

                            if (!emit_do_while_header_if_needed(st, eq_line0, eq_col0, -2)) goto fail_emit_assign;

                            if (!ael_emit_at(out, eq_line0, decl_col0)) {
                                if (err && err_cap) snprintf(err, err_cap, "cannot seek to line %d", eq_line0);
                                expr_free(rhs);
                                expr_free(lhs);
                                goto fail;
                            }
                            if (!ael_emit_text(out, "decl ")) goto fail_emit_assign;
                            if (!ael_emit_text(out, lhs->text)) goto fail_emit_assign;

                            if (allow_decl_init_chain) {
                                st->decl_init_chain.active = true;
                                st->decl_init_chain.line0 = eq_line0;
                                st->decl_init_chain.is_local = st->pending_decls.is_local;
                                st->decl_init_chain.in_function = st->pending_decls.in_function;
                                st->decl_init_chain.depth = st->pending_decls.depth;
                            } else {
                                st->decl_init_chain.active = false;
                            }
                        } else {
                            /* Continuation of a comma-separated decl initializer statement:
                               "decl a=..., b=..., c=...;" */
                            if (!ael_emit_text(out, lhs->text)) goto fail_emit_assign;
                        }

                    /* Position '=' exactly at IR's column; this naturally yields either "x=..." or "x = ...". */
                    if (!ael_emit_at(out, eq_line0, eq_col0)) goto fail_emit_assign;
                    if (!ael_emit_text(out, "=")) goto fail_emit_assign;

                        /* Start RHS just after '='; in the spaced decl style ("decl x = ..."),
                           skip the space column so identifiers match baseline anchors. */
                        int rhs_col0 = eq_col0 + 1;
                        if (is_decl) {
                            int eq_col0_min = decl_col0 + 5 + (int)strlen(lhs->text); /* "decl " + name */
                            if (eq_col0 > eq_col0_min) rhs_col0 = eq_col0 + 2;
                        }
                        if (!ael_emit_at(out, eq_line0, rhs_col0)) goto fail_emit_assign;

                        if (!emit_expr_addr(out, rhs, 0)) goto fail_emit_assign;

                        if (allow_decl_init_chain && has_next_decl_init_on_same_line(program, i, eq_line0)) {
                            if (!ael_emit_text(out, ", ")) goto fail_emit_assign;
                        } else {
                            if (!ael_emit_text(out, ";\n")) goto fail_emit_assign;
                            st->decl_init_chain.active = false;
                        }
                    } else {
                        /* Assignment statement: arg2/arg3 refers to identifier position. */
                        int id_line0 = inst->has_arg2 ? inst->arg2 : 0;
                        int id_col0 = inst->has_arg3 ? inst->arg3 : 0;
                        if (st->in_function && !anon_close_scopes_before_stmt(out, &st->anon_depth_sp, st->anon_depth_stack, st->cur_depth, id_line0)) goto fail_emit_assign;

                        /* Ensure pending decls (e.g., 'decl x;') are emitted before first use. */
                        if (st->pending_decls.count > 0) {
                            /* If this was a plain 'decl x;' (not initializer), flush it now. */
                            int decl_line0 = id_line0 - 1;
                            if (decl_line0 < 0) decl_line0 = 0;
                            int decl_col0 = st->pending_decls.is_local ? decl_indent_col0_from_depth(st->pending_decls.depth > 0 ? st->pending_decls.depth : 1) : 0;
                            if (st->pending_decls.is_local && st->pending_decls.depth > 1) {
                                /* Rely on explicit control-flow braces; avoid inserting extra blocks that can
                                   break if/else association. */
                            }
                            if (!decl_group_emit_and_track(out, &st->pending_decls, decl_line0, decl_col0, &st->local_init)) goto fail_emit_assign;
                            decl_group_clear(&st->pending_decls);
                        }

                    if (!switch_emit_pending_case_before_stmt(out, &st->sw, id_line0, id_col0, &st->anon_depth_sp, st->anon_depth_stack)) goto fail_emit_assign;

                    if (!emit_do_while_header_if_needed(st, id_line0, id_col0, -4)) goto fail_emit_assign;

                    if (!ael_emit_at(out, id_line0, id_col0)) goto fail_emit_assign;
                     /* Compound assignment template: lhs += rhs (encoded as DUP/LVALUE + binop + ASSIGN). */
                     if (lhs->kind == EXPR_VAR && rhs && rhs->kind == EXPR_BINOP && rhs->lhs &&
                         rhs->lhs->kind == EXPR_VAR && rhs->lhs->text && lhs->text &&
                         strcmp(rhs->lhs->text, lhs->text) == 0 &&
                         (rhs->lhs->flags & EXPR_FLAG_LVALUE_DUP) != 0 &&
                         (rhs->op_code == 10 || rhs->op_code == 11 || rhs->op_code == 12 || rhs->op_code == 14 || rhs->op_code == 13)) {

                        const char *cops = (rhs->op_code == 10) ? "+=" :
                                           (rhs->op_code == 11) ? "-=" :
                                           (rhs->op_code == 12) ? "*=" :
                                           (rhs->op_code == 14) ? "/=" : "%=";

                        if (!ael_emit_text(out, lhs->text)) goto fail_emit_assign;
                        if (rhs->op_line0 >= 0 && rhs->op_col0 >= 0) {
                            if (!ael_emit_at(out, rhs->op_line0, rhs->op_col0)) goto fail_emit_assign;
                        } else {
                            if (!ael_emit_char(out, ' ')) goto fail_emit_assign;
                        }
                        if (!ael_emit_text(out, cops)) goto fail_emit_assign;
                        if (!ael_emit_char(out, ' ')) goto fail_emit_assign;
                        if (!emit_expr_addr(out, rhs->rhs, 0)) goto fail_emit_assign;

                        if (!emit_stmt_end_from_ir(program, &i, out, id_line0, true)) goto fail_emit_assign;
                    } else {
                        if (lhs->kind == EXPR_VAR) {
                            if (!ael_emit_text(out, lhs->text)) goto fail_emit_assign;
                        } else {
                            if (!emit_expr_addr(out, lhs, 0)) goto fail_emit_assign;
                        }
                        if (!ael_emit_text(out, " = ")) goto fail_emit_assign;
                        if (!emit_expr_addr(out, rhs, 0)) goto fail_emit_assign;

                        if (!emit_stmt_end_from_ir(program, &i, out, id_line0, false)) goto fail_emit_assign;
                    }
                }

                expr_free(rhs);
                expr_free(lhs);
                stack_clear(st->stack, &st->stack_len);
                decl_group_clear(&st->pending_decls);

                continue;

            fail_emit_assign:
                expr_free(rhs);
                expr_free(lhs);
                if (err && err_cap) {
                    snprintf(
                        err, err_cap,
                        "emit failed at IR index %zu (OP=%d arg1=%d arg2=%d arg3=%d) at out=%d:%d req=%d:%d (reason=%d)",
                        i,
                        inst ? inst->op : -1,
                        inst && inst->has_arg1 ? inst->arg1 : -1,
                        inst && inst->has_arg2 ? inst->arg2 : -1,
                        inst && inst->has_arg3 ? inst->arg3 : -1,
                        out ? out->line0 : -1, out ? out->col0 : -1,
                        out ? out->last_req_line0 : -1, out ? out->last_req_col0 : -1,
                        out ? (int)out->last_fail_reason : -1
                    );
                }
                goto fail;
            }

    } while (0);
    RETURN_STATUS(IR2AEL_STATUS_HANDLED);
oom:
    RETURN_STATUS(IR2AEL_STATUS_OOM);
fail:
    RETURN_STATUS(IR2AEL_STATUS_FAIL);
#undef RETURN_STATUS
}
